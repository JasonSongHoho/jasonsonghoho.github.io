<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jason&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasonsonghoho.github.io/"/>
  <updated>2018-10-30T09:03:13.706Z</updated>
  <id>https://jasonsonghoho.github.io/</id>
  
  <author>
    <name>jason song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BitMap、BitSet与Bloom Filter</title>
    <link href="https://jasonsonghoho.github.io/2018/10/08/BitMap%E3%80%81BitSet%E4%B8%8EBloom%20Filter/"/>
    <id>https://jasonsonghoho.github.io/2018/10/08/BitMap、BitSet与Bloom Filter/</id>
    <published>2018-10-08T02:36:11.000Z</published>
    <updated>2018-10-30T09:03:13.706Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：5分钟</em></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>先来看一个问题，假设现在有范围为 1-10 亿的 11 亿个 int 型整数，如何排除掉其中的重复数字？int 占 4 个字节，可以表示 -2,147,483,648 ~ +2,147,483,647 的数据。<br>所以一般的思路是会将这 11 亿个数作为 int 型数据存到一个 HashSet 集合中进行去重。但是，这样会存在一个问题。我们知道 1GB=1024KB=1024 <em> 1024Byte,那么 10亿 </em> 4Byte 将占用接近 4GB 的内存，这将是极大的性能浪费，很可能会影响程序的健康运行。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以考虑用”位映射（BitMap）”来解决这个问题。试想一下，如果我们有一个位数组（bit[n]），那么我们可以用 bit[i] 来表示 0-n 中对应的数字，每个元素有 1 和 0 两个取值，分别代表该数字存在与否。这样一来，我们记录一个数字只需要一个 bit，相对于之前的 int 类型(32 bit)，整整缩小了 32 倍的存储大小(4GB/32=125MB)!</p><p>扩展一下，当我们需要记录每个数字出现次数是否超过 2 次时，可以使用连续的两位来记录一个数字：一位用来记录是否出现，另一位用来记录是否超过 2 次。</p><p>不过，Java 中无法创建 bit 数组，我们可以使用 int 或 long 数组来实现这个目的。建立一个 int 数组 int[n]，int[0] 记录了 0-31，int[1] 记录了 32-63 …… 依此类推。</p><h3 id="Java-BitSet"><a href="#Java-BitSet" class="headerlink" title="Java BitSet"></a>Java BitSet</h3><p>Java 中有一个 BitSet 类，从命名就可以看出它是用来存储去重的位元素集合，它还支持 and、or 等位运算。用来解决文章开头的问题非常合适，方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitSetStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet(<span class="number">1000000000</span>);</span><br><span class="line">        <span class="comment">//随机生成 11 亿个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1100000000</span>; i++) &#123;</span><br><span class="line">            bitSet.set((<span class="keyword">int</span>) (Math.random() * <span class="number">1000000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(bitSet.size());</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 jconsole,可以看到存储了 bitset 对象的老年代所占用的内存稳定在 125MB 左右。</p><img src="/2018/10/08/BitMap、BitSet与Bloom%20Filter/bitset-mem.png"><p>关于 BitSet 的 and、andNot、or、xor 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BitSet bitSet = <span class="keyword">new</span> BitSet();</span><br><span class="line">    bitSet.set(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    BitSet bitSet1 = <span class="keyword">new</span> BitSet();</span><br><span class="line">    bitSet1.set(<span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    BitSet bitSetAnd = (BitSet) bitSet.clone();</span><br><span class="line">    BitSet bitSetAndNot = (BitSet) bitSet.clone();</span><br><span class="line">    BitSet bitSetOr = (BitSet) bitSet.clone();</span><br><span class="line">    BitSet bitSetXor = (BitSet) bitSet.clone();</span><br><span class="line"></span><br><span class="line">    bitSetAnd.and(bitSet1);</span><br><span class="line">    bitSetAndNot.andNot(bitSet1);</span><br><span class="line">    bitSetOr.or(bitSet1);</span><br><span class="line">    bitSetXor.xor(bitSet1);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"bitSet is : "</span> + bitSet + <span class="string">" , and bitSet1 is: "</span> + bitSet1);</span><br><span class="line">    System.out.println(<span class="string">"run bitSet.XMethod(bitSet1) , result is : "</span>);</span><br><span class="line">    System.out.println(<span class="string">"and:"</span> + bitSetAnd);</span><br><span class="line">    System.out.println(<span class="string">"andNot:"</span> + bitSetAndNot);</span><br><span class="line">    System.out.println(<span class="string">"or:"</span> + bitSetOr);</span><br><span class="line">    System.out.println(<span class="string">"xor:"</span> + bitSetXor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bitSet is : &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; , and bitSet1 is: &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">run bitSet.XMethod(bitSet1) , result is :</span><br><span class="line">and:&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">andNot:&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">or:&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">xor:&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="自己实现-BitMap"><a href="#自己实现-BitMap" class="headerlink" title="自己实现 BitMap"></a>自己实现 BitMap</h3><p>Java 的 BitSet 使用起来存在局限性，我们可以参考 BitSet 实现自己的 BitMap 来扩展应用场景。核心还是通过 int/long 数组元素的位来记录有序数据，一个实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] words;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="comment">//每个int占32位，数组大小为 n/32+1</span></span><br><span class="line">        words = <span class="keyword">new</span> <span class="keyword">int</span>[(size &gt;&gt; <span class="number">5</span>) + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得数据所在的数组序号（int），相当于 bit/32</span></span><br><span class="line">        <span class="keyword">int</span> i = bit &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//获得该int元素中要修改为1的数字,相当于 bit%32</span></span><br><span class="line">        <span class="keyword">int</span> j = bit &amp; <span class="number">31</span>;</span><br><span class="line">        <span class="comment">//获得要修改的位</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">        <span class="comment">//将该元素相应的二进制位设为1</span></span><br><span class="line">        words[i] |= k ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//参考set方法理解</span></span><br><span class="line">        <span class="keyword">return</span> (words[bit &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (bit &amp; <span class="number">31</span>))) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了核心的存储结构、set 和 get 方法。</p><h3 id="布隆过滤器-Bloom-Filter"><a href="#布隆过滤器-Bloom-Filter" class="headerlink" title="布隆过滤器(Bloom Filter)"></a>布隆过滤器(Bloom Filter)</h3><p>了解完 BitMap,我们掌握了一种处理大量连续数据的好方法。现在继续扩展一下，现在如果我们要记录的是海量的分布很不均匀的数据，如果继续用 BitMap 的方式，将会浪费大量的存储空间，或者数据量已经大到使用 BitMap 的方式，仍然会浪费大量的内存空间。面对这两种情情况时，我们可以考虑使用布隆过滤器。</p><p>布隆过滤器核心是对一个 key 使用多个 hash 函数求出多个值，将这些值散列在一个有限的数组中，这样，当这些 hash 函数求出的值都符合预期就认为该 key 存在；若只要存在 hash 函数的值不符合，就可以确定它不存在。在某些场景下，这种方法效果非常好。图示如下：</p><img src="/2018/10/08/BitMap、BitSet与Bloom%20Filter/bloom_filter.jpeg"><p>可以看出来，这种方法存在一定误差，不过误差几率可以通过增加 hash 函数和散列数组大小来减小。还有一个问题就是，当某个 key 被删除后，不能直接在散列表中将对应的 value 去掉，因为可能会影响其他 key。针对这个问题，我们可以维护一个黑名单，每次计算 hash 前，先判断 key 是否在黑名单中，有则表示该 key 已删掉。</p><img src="/2018/10/08/BitMap、BitSet与Bloom%20Filter/IMG_1753.GIF" title="10栋*7层*2（至少2）套=140套 呵呵😅">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：5分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;先来看一个问题，假设现在有范围为 1-10 亿的 11 亿个 int 型整数，如何排除
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="BitMap" scheme="https://jasonsonghoho.github.io/public/tags/BitMap/"/>
    
      <category term="BitSet" scheme="https://jasonsonghoho.github.io/public/tags/BitSet/"/>
    
      <category term="布隆过滤器" scheme="https://jasonsonghoho.github.io/public/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="Bloom Filter" scheme="https://jasonsonghoho.github.io/public/tags/Bloom-Filter/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 HashMap(上)—— 红黑树</title>
    <link href="https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap-%E4%B8%8A-%E2%80%94%E2%80%94-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap-上-——-红黑树/</id>
    <published>2018-09-23T16:19:04.000Z</published>
    <updated>2018-09-23T16:45:18.176Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：10分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Java8的最大特性是使用红黑树结构来存储每个（桶）bucket中的数据（当链表长度超过8时）。<br>为什么引入红黑树呢？其实正常情况下，平均每个桶中应该只会有不到1个数据，但当发生大量Hash碰撞时，每个桶中的数据也将会大量增加，这将会影响到数据的查询速度。在Java7中，每个桶使用链表存储数据，查找数据采用遍历的方式，查询时间复杂度为O(n)。Java7中为了避免大量Hash碰撞的问题，引入了hashseed方式，增强了Hash函数的散列性。但是randomHashSeed方法调用的next方法在多线程运算时存在性能问题（待考证），故在Java8中被弃用。Java8中换了一个思路：使用红黑树来提高查找速度（O(logN)），即使发生大量hash碰撞也不会造成性能影响，这便是红黑树由来的原因。<br>Java7的HashMap一共有接近1200行代码，而到了Java8直接增加到了2400行，减去全局变量前新加的100行注释，相差1100行。其中TreeNode(红黑树)实现部分有600行代码，再加上其他方法对红黑树的适应性改动，可见红黑树部分是Java8 HashMap的主要改动。  </p></blockquote><h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><h4 id="继承关系如下："><a href="#继承关系如下：" class="headerlink" title="继承关系如下："></a>继承关系如下：</h4><img src="/2018/09/24/Java-8-HashMap-上-——-红黑树/20180923214733.png"><p>TreeNode继承了LinkedHashMap.Entry，LinkedHashMap.Entry继承了HashMap.Node，而Node其实就是上个版本的Entry（链表）结构。此处有个疑惑：TreeNode并没有使用LinkedHashMap.Entry的before和after字段，不知道为啥不直接继承Node类。</p><h4 id="字段和构造函数如下："><a href="#字段和构造函数如下：" class="headerlink" title="字段和构造函数如下："></a>字段和构造函数如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//常见的树结构</span></span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; parent;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; left;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; right;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; prev;</span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, HashMap.Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树全部方法如下："><a href="#红黑树全部方法如下：" class="headerlink" title="红黑树全部方法如下："></a>红黑树全部方法如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取根结点</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选取根结点</span></span><br><span class="line"><span class="comment"> * 红黑树进行左旋、右旋后，根结点可能移动，头结点需要重新指向新的根结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(HashMap.Node&lt;K,V&gt;[] tab, HashMap.TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; first = (HashMap.TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="comment">//如果根结点不是桶的第一个节点，则将根结点移动到头结点位置</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            HashMap.Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            HashMap.TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                ((HashMap.TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言红黑树结构是否正常，不正常则报异常停止</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据结点hash值、key和key的类型 进行红黑树查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//待查询结点的key的hash值若小于当前结点则进入左子树，否则进入右子树</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//如果hash值相等再比较key，一致则表示找到，返回结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//如果key不同，则看key的类型是否可比较，</span></span><br><span class="line">        <span class="comment">//如果可以比较则根据比较结果选择是否返回查询结果，还是继续查询左、右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据结点hash值、key 进行红黑树查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制比较两个结点的key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当两个类型不能直接比较时，通过对类名进行hash进行比较；若hash值也相等，判定b大。</span></span><br><span class="line"><span class="comment"> * 故一定会排出先后顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">            (d = a.getClass().getName().</span><br><span class="line">                    compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表转化为红黑树</span></span><br><span class="line"><span class="comment"> * 重要方法！当链表长度增加到红黑树转换阈值（默认8），且桶的数量不小于64 时触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(HashMap.Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (HashMap.TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//首结点作为根结点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果未能比较，调用强制比较方法，确保有序</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//当左或右子树为空时，插入链表上的一个结点</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//插入结点后，进行左旋、右旋重平衡，转换为红黑树</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保根结点是首结点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转换为链表</span></span><br><span class="line"><span class="comment"> * 当红黑树结点减少到链表还原阈值（默认6）时触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        HashMap.Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树插入新结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, HashMap.Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//插入结点与当前结点hash值相等时，查找左子树或右子树，若已包含待插入结点则直接返回结果</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">//若已比较到左子树或右子树为空时还没有找到，则插入该结点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashMap.Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            HashMap.TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((HashMap.TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除红黑树结点</span></span><br><span class="line"><span class="comment"> * 呃，这个方法和前面的比起来大同小异，不细看了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, HashMap.Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; first = (HashMap.TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; succ = (HashMap.TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">            (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//若删除结点后，达到链表还原阈值，则还原为链表</span></span><br><span class="line">        tab[index] = first.untreeify(map);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            HashMap.TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树分为两半</span></span><br><span class="line"><span class="comment"> * 扩容时，会将一个桶中的红黑树拆分为两个；若拆分后红黑树不够大，会被还原为链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, HashMap.Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (HashMap.TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树的左旋</span></span><br><span class="line"><span class="comment"> * 红黑树相关知识待深入学习后进一步探讨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              HashMap.TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树的右旋</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               HashMap.TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入结点后进行重平衡</span></span><br><span class="line"><span class="comment"> * 这部分只看懂代码了，算法比较懵，有机会再探讨红黑树算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root, HashMap.TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将插入的结点设为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//x为根结点时，设为黑色，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//父结点为黑且为根结点时，直接返回。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//父结点为祖父结点的左孩子结点时：</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//祖父结点的右孩子结点为红色时，叔叔结点和父结点置黑，祖父结点置红，设置当前结点为祖父结点</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则，如果当前结点为父结点的右孩子结点，进行左旋</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果父结点不为空设为黑色，且如果祖父结点不为空则设为红色并进行右旋</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除结点后进行重平衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   HashMap.TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                        (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                        (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查红黑树结构是否正常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">            tb = t.prev, tn = (HashMap.TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/09/24/Java-8-HashMap-上-——-红黑树/IMG_1756.GIF"><p>Java8的HashMap解读暂告一段落，下期继续探讨其他特性，希望不要太久😂</p><p><a href="https://y.qq.com/n/yqq/song/004dbfuf1jEjpI.html#stat=y_new.index.new_song.songname" target="_blank" rel="noopener">https://y.qq.com/n/yqq/song/004dbfuf1jEjpI.html#stat=y_new.index.new_song.songname</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：10分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Java8的最大特性是使用红黑树结构来存储每个（桶）buc
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="HashMap" scheme="https://jasonsonghoho.github.io/public/tags/HashMap/"/>
    
      <category term="红黑树" scheme="https://jasonsonghoho.github.io/public/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 HashMap(下)—— compute</title>
    <link href="https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94%20compute/"/>
    <id>https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap（下）—— compute/</id>
    <published>2018-09-23T16:19:04.000Z</published>
    <updated>2018-10-04T07:57:06.137Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/09/24/Java-8-HashMap（下）——%20compute/IMG_0011.JPG" title="故乡的月"><p><em>推荐阅读时间：5分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本篇接上篇 <a href="https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap-%E4%B8%8A-%E2%80%94%E2%80%94-%E7%BA%A2%E9%BB%91%E6%A0%91/">Java 8 HashMap (上)—— 红黑树</a>，<br>继续探讨 Java8 的HashMap 的新特性。内容不多，重点介绍 compute 方法。</p><h3 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h3><p>compute 方法主要用来将一个复杂计算的结果作为值赋给指定的键。key 指待修改或插入的键，remappingFunction 是一个 BiFunction 对象。<br>BiFunction 是指一个 二元（binary）函数；定义时，指定两个入参字段类型和一个结果字段类型。通过实现 apply 方法来自定义计算逻辑。</p><p>BiFunction 部分源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>compute 方法源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//根据 key 值，找到对应的 旧值</span></span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">    <span class="comment">//计算出新值</span></span><br><span class="line">    V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果新值为 null，删掉这个 Node</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新值不为 null，替换这个 Node</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>computeIfAbsent、computeIfPresent 方法与 compute 类似，分别表示当相应键的值缺席、存在时，才进行 compute 方法。<br>源码与 compute 基本一致，不赘述。</p><p>demo 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">    hashMap.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">    hashMap.put(<span class="string">"k3"</span>, <span class="string">"v3"</span>);</span><br><span class="line">    Function&lt;String, String&gt; function = <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"test_"</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    BiFunction&lt;String, String, String&gt; biFunction = <span class="keyword">new</span> BiFunction&lt;String, String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s, String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"test_"</span> + s + <span class="string">"_"</span> + s2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    hashMap.compute(<span class="string">"k1"</span>, biFunction);<span class="comment">//生效</span></span><br><span class="line">    hashMap.compute(<span class="string">"k11"</span>, biFunction);<span class="comment">//生效</span></span><br><span class="line">    hashMap.computeIfAbsent(<span class="string">"k2"</span>, function);<span class="comment">//不生效</span></span><br><span class="line">    hashMap.computeIfAbsent(<span class="string">"k21"</span>, function);<span class="comment">//生效</span></span><br><span class="line">    hashMap.computeIfPresent(<span class="string">"k3"</span>, biFunction);<span class="comment">//生效</span></span><br><span class="line">    hashMap.computeIfPresent(<span class="string">"k31"</span>, biFunction);<span class="comment">//不生效</span></span><br><span class="line">    System.out.println(hashMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;k1=test_k1_v1, k2=v2, k3=test_k3_v3, k11=test_k11_null, k21=test_k21&#125;</span><br></pre></td></tr></table></figure></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge 方法是根据旧值进行计算，修改相应 Node。与 compute 结构相似，不过 BiFunction 入参为 oldValue,newValue。<br>源码与 compute 基本一致，不赘述。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他新增的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>getOrDefault 方法根据 key 获取相应的值，如果为 null，则返回设置的默认值。</li><li>putIfAbsent 方法会在 指定的 key 不存在时，插入相应的值。</li><li>remove(Object key, Object value) 方法会根据 key 和 value 进行删除，如果 相应 key 的值不为该 value，则不执行删除并返回 false。</li><li>replace(K key, V oldValue, V newValue) 与 replace(K key, V value) 都是替换值的操作，具体区别与上述方法类似。</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>HashMap历时一个半月，终于告一段落了😂。</p><p>由于在源码分析系列含有大量代码，放在公众号上不方便阅读，后续写的话会发在博客上。有兴趣的欢迎访问 <a href="http://jasonsonghoho.github.io">http://jasonsonghoho.github.io</a> 。</p><hr><img src="/2018/09/24/Java-8-HashMap（下）——%20compute/IMG_0007.JPG"><p><em>“你不知<br>这风雪一程<br>有太多不易”</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/09/24/Java-8-HashMap（下）——%20compute/IMG_0011.JPG&quot; title=&quot;故乡的月&quot;&gt;
&lt;p&gt;&lt;em&gt;推荐阅读时间：5分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="HashMap" scheme="https://jasonsonghoho.github.io/public/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java 7 HashMap 源码解读</title>
    <link href="https://jasonsonghoho.github.io/2018/08/18/Java-7-HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://jasonsonghoho.github.io/2018/08/18/Java-7-HashMap-源码解读/</id>
    <published>2018-08-18T02:31:46.000Z</published>
    <updated>2018-09-22T02:33:29.034Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/nHk9jKapNVVkBDnKChgK0Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nHk9jKapNVVkBDnKChgK0Q</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/nHk9jKapNVVkBDnKChgK0Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/nHk9jKapNVVkBDn
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="HashMap" scheme="https://jasonsonghoho.github.io/public/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>React快速入门</title>
    <link href="https://jasonsonghoho.github.io/2018/06/24/React%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://jasonsonghoho.github.io/2018/06/24/React快速入门/</id>
    <published>2018-06-24T02:34:27.000Z</published>
    <updated>2018-09-22T02:52:12.539Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zfzKQr1jQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zfzKQr1jQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zfzKQr1jQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zf
      
    
    </summary>
    
      <category term="前端" scheme="https://jasonsonghoho.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="React" scheme="https://jasonsonghoho.github.io/public/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>动物园管理员——ZooKeeper</title>
    <link href="https://jasonsonghoho.github.io/2018/06/05/%E5%8A%A8%E7%89%A9%E5%9B%AD%E7%AE%A1%E7%90%86%E5%91%98%E2%80%94%E2%80%94ZooKeeper/"/>
    <id>https://jasonsonghoho.github.io/2018/06/05/动物园管理员——ZooKeeper/</id>
    <published>2018-06-05T02:35:00.000Z</published>
    <updated>2018-09-22T02:52:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoXHKwJhiw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoXHKwJhiw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoXHKwJhiw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoX
      
    
    </summary>
    
      <category term="中间件" scheme="https://jasonsonghoho.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="ZooKeeper" scheme="https://jasonsonghoho.github.io/public/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>MySQL究竟如何解决“不可重复读”和“幻读”的</title>
    <link href="https://jasonsonghoho.github.io/2018/05/27/MySQL%E7%A9%B6%E7%AB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%80%9C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E2%80%9D%E5%92%8C%E2%80%9C%E5%B9%BB%E8%AF%BB%E2%80%9D%E7%9A%84/"/>
    <id>https://jasonsonghoho.github.io/2018/05/27/MySQL究竟如何解决“不可重复读”和“幻读”的/</id>
    <published>2018-05-26T16:35:44.000Z</published>
    <updated>2018-09-22T02:30:44.066Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL0-J8tIQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL0-J8tIQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL0-J8tIQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL
      
    
    </summary>
    
      <category term="数据库" scheme="https://jasonsonghoho.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="mysql" scheme="https://jasonsonghoho.github.io/public/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>我们为提升 Cassandra 读性能做了哪些努力？</title>
    <link href="https://jasonsonghoho.github.io/2018/05/21/180521/"/>
    <id>https://jasonsonghoho.github.io/2018/05/21/180521/</id>
    <published>2018-05-21T14:08:41.000Z</published>
    <updated>2018-09-20T15:23:28.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title=" 目录 (Table of Contents)"></a> <strong>目录 (Table of Contents)</strong></h2><ul><li>关于Cassandra</li><li>提升读性能</li></ul><h2 id="关于Cassandra"><a href="#关于Cassandra" class="headerlink" title="关于Cassandra"></a>关于Cassandra</h2><p>Apache Cassandra是一个高度可扩展的高性能分布式数据库，<br>用于处理大量常规服务器上的大量数据，提供高可用性，无单点故障。它是一种NoSQL类型的数据库。</p><p>我们看一下国外权威机构<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">DB-Engines</a>最近的数据库全球流行程度排名：</p><img src="/2018/05/21/180521/database_rank.png" title="数据库排名"><p>可以看出，Cassandra 是排名前十中四个仅有的NoSQL数据库之一。Cassandra在国外这样受欢迎，其性能可想而知不会差，<br>但是在国内貌似还没有多少公司使用，且国内关于 Cassandra方面的资料较少。</p><h2 id="提升读性能"><a href="#提升读性能" class="headerlink" title="提升读性能"></a>提升读性能</h2><p>Cassandra 在我们的项目中用来存储时序数据，经过测试，在三台4核16G的虚拟机上，<br>指标数据的写入TPS可以达到6.5W/s，基本可以满足我们的业务需求。<br>但是读取性能可能就会差很多，因为数据查询速度跟每次查询的数据量关系比较大，此处也不好定义TPS。<br>产品查询一周以上的指标数据时，经常会出现加载缓慢，甚至查询超时。为了改善查询状况，我们进行了不少努力。</p><p>此处不讨论纵向扩展和横向扩展带来的性能提升。</p><h3 id="1-加快墓碑回收甚至去除墓碑"><a href="#1-加快墓碑回收甚至去除墓碑" class="headerlink" title="1. 加快墓碑回收甚至去除墓碑"></a>1. 加快墓碑回收甚至去除墓碑</h3><p>在Cassandra中，当你删除一条数据时，其实是给这条数据进行update，给它update上一个标识，就是一个墓碑标识。<br> 当Cassandra集群在不同节点之间同步删除信息的时候，也会用到Tombstones(墓碑)，可以说墓碑是一种允许Cassandra快速写入的机制。</p><p>关于墓碑的更多消息，可参考 <a href="https://docs.datastax.com/en/Cassandra/3.0/Cassandra/dml/dmlHowDataMaintain.html" target="_blank" rel="noopener">Cassandra 数据维护官方文档</a></p><p>可以这样理解，大量的墓碑数据会使查询时搜索的数据量变大，直接影响查询时的效率。<br>所以，为了消除这种影响，我们可以加快墓碑数据的回收，避免产生大量的墓碑数据。<br>甚至，当我们在写入时，若写入一致性的值与副本因子数量相等时，可以不产生墓碑数据，直接删掉该无效数据。<br>具体可通过 调整 table 中 gc_grace_seconds 参数来实现，默认为 864000（10天），我们可以设为 86400（1天）或者0（直接删除）。</p><h3 id="2-降低read-repair-的几率"><a href="#2-降低read-repair-的几率" class="headerlink" title="2. 降低read repair 的几率"></a>2. 降低read repair 的几率</h3><p>每一次读操作，Cassandra都会在后台进行read repair操作。<br>如果只要求读一个节点数据，Cassandra在读到一个节点后，就将结果返回客户端，<br>然后用read repair对其他的replicas进行同步（根据timestamp）。<br>如果要求读多个节点，那么Cassandra就读多个节点，然后根据timestamp进行比较，返回客户端最新的数据，<br>然后再调用read repair对其他节点进行同步。<br>Read repair在后台的操作，会占用一定的CPU和I/O,所以影响读性能。<br>我们可以降低read repair 的几率，以提高读取性能。</p><p>通过修改 table 中 read_repair_chance（取值范围 0-1）参数来设置read repair 的几率，建议设为 0.1。</p><h3 id="3-指标数据预聚合"><a href="#3-指标数据预聚合" class="headerlink" title="3. 指标数据预聚合"></a>3. 指标数据预聚合</h3><p>思路：我们存在数据库中的指标数据，读取时会将指定时间范围内的数据进行聚合。<br>如果提前将数据按基本时间段提前聚合为一个值，读取时，只读取时间范围内的时间段的汇聚结果，将大大减少查询耗时。</p><h3 id="4-合理部署产品"><a href="#4-合理部署产品" class="headerlink" title="4. 合理部署产品"></a>4. 合理部署产品</h3><p>公司的其他产品使用了mongoDB，线上环境中发现，这两个NoSQL数据库部署在一起时会相互争夺内存资源，<br>十分影响性能，因此最好将这两个数据库分开部署。</p><h3 id="5-设置合理的堆内存大小和GC策略"><a href="#5-设置合理的堆内存大小和GC策略" class="headerlink" title="5. 设置合理的堆内存大小和GC策略"></a>5. 设置合理的堆内存大小和GC策略</h3><p>堆内存设置的太小，将导致频繁GC甚至OOM，设置的太大同样也不好。可参考官方的公式:<br><code>MAX_HEAP_SIZE=max(min(1/2 ram, 1024MB), min(1/4 ram, 8GB)</code></p><p>关于GC策略，官方的建议是：小于16G，用CMS收集器；16-64G，用G1收集器。</p><h3 id="6-设置合理的压式策略"><a href="#6-设置合理的压式策略" class="headerlink" title="6. 设置合理的压式策略"></a>6. 设置合理的压式策略</h3><p>Cassandra 将落到磁盘的数据存放在SStable中，压实是将多个SSTable 文件合并为一个的过程。合并后将减少重复的数据，使数据更紧凑。<br>Cassandra 有多种触发压实的策略，选一个适合的压实策略，可以更好地压实数据。<br>比如，我们使用的Kairosdb建议采用 DateTieredCompactionStrategy (<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html#dmlHowDataMaintain__dtcs-compaction" target="_blank" rel="noopener">DTCS</a>))压实策略。</p><h3 id="7-启用-row-cache"><a href="#7-启用-row-cache" class="headerlink" title="7. 启用 row cache"></a>7. 启用 row cache</h3><p>row cache 把整个row 的内容都放在内存中。<br>适合的情况是，有一小部分hot data是经常反问的，或者要返回整个columns.在使用row cache时，用注意它对内存的影响。<br>可参考 Cassandra 的<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsConfiguringCaches.html" target="_blank" rel="noopener">官方文档</a>设置row cache。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>安利一个入门Cassandra 的好博客：<a href="http://teddymaef.github.io/learnCassandra/cn/" target="_blank" rel="noopener">learn Cassandra</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录-Table-of-Contents&quot;&gt;&lt;a href=&quot;#目录-Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot; 目录 (Table of Contents)&quot;&gt;&lt;/a&gt; &lt;strong&gt;目录 (Table of C
      
    
    </summary>
    
      <category term="数据库" scheme="https://jasonsonghoho.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="cassandra" scheme="https://jasonsonghoho.github.io/public/tags/cassandra/"/>
    
      <category term="大数据" scheme="https://jasonsonghoho.github.io/public/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的top命令详解</title>
    <link href="https://jasonsonghoho.github.io/2018/05/20/Linux%E4%B8%AD%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jasonsonghoho.github.io/2018/05/20/Linux中的top命令详解/</id>
    <published>2018-05-20T02:41:23.000Z</published>
    <updated>2018-09-22T02:52:12.563Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y9MM-7JA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y9MM-7JA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y9MM-7JA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y
      
    
    </summary>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/categories/Linux/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/public/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的 Cache、Buffer、MemAvailable、Swap简介</title>
    <link href="https://jasonsonghoho.github.io/2018/05/20/Linux-%E7%9A%84-Cache%E3%80%81Buffer%E3%80%81MemAvailable%E3%80%81Swap%E7%AE%80%E4%BB%8B/"/>
    <id>https://jasonsonghoho.github.io/2018/05/20/Linux-的-Cache、Buffer、MemAvailable、Swap简介/</id>
    <published>2018-05-20T02:40:08.000Z</published>
    <updated>2018-09-22T02:52:12.543Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/59oH1hMMXy6YC618gZkm1g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/59oH1hMMXy6YC618gZkm1g</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/59oH1hMMXy6YC618gZkm1g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/59oH1hMMXy6YC61
      
    
    </summary>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/categories/Linux/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/public/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>克拉丝的面试</title>
    <link href="https://jasonsonghoho.github.io/2018/05/13/%E5%85%8B%E6%8B%89%E4%B8%9D%E7%9A%84%E9%9D%A2%E8%AF%95/"/>
    <id>https://jasonsonghoho.github.io/2018/05/13/克拉丝的面试/</id>
    <published>2018-05-13T02:39:39.000Z</published>
    <updated>2018-09-22T02:52:46.942Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU_mAUWbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU_mAUWbA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU_mAUWbA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="JVM" scheme="https://jasonsonghoho.github.io/public/tags/JVM/"/>
    
      <category term="类加载" scheme="https://jasonsonghoho.github.io/public/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式、简单工厂模式与抽象工厂模式</title>
    <link href="https://jasonsonghoho.github.io/2018/05/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jasonsonghoho.github.io/2018/05/10/工厂模式、简单工厂模式与抽象工厂模式/</id>
    <published>2018-05-10T02:39:16.000Z</published>
    <updated>2018-09-22T02:52:12.556Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/ccNz_veqyb4UYBpH-UpZfA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ccNz_veqyb4UYBpH-UpZfA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/ccNz_veqyb4UYBpH-UpZfA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/ccNz_veqyb4UYBp
      
    
    </summary>
    
      <category term="设计模式" scheme="https://jasonsonghoho.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="设计模式" scheme="https://jasonsonghoho.github.io/public/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>园丁与盆栽（JVM 垃圾回收）</title>
    <link href="https://jasonsonghoho.github.io/2018/05/01/%E5%9B%AD%E4%B8%81%E4%B8%8E%E7%9B%86%E6%A0%BD/"/>
    <id>https://jasonsonghoho.github.io/2018/05/01/园丁与盆栽/</id>
    <published>2018-05-01T02:38:55.000Z</published>
    <updated>2018-09-22T02:52:12.553Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/2GO3Sc4mD8BVN3PnfJQixg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2GO3Sc4mD8BVN3PnfJQixg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/2GO3Sc4mD8BVN3PnfJQixg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/2GO3Sc4mD8BVN3P
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="JVM" scheme="https://jasonsonghoho.github.io/public/tags/JVM/"/>
    
      <category term="GC" scheme="https://jasonsonghoho.github.io/public/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>克拉丝的JVM工厂之旅（上）</title>
    <link href="https://jasonsonghoho.github.io/2018/04/15/%E5%85%8B%E6%8B%89%E4%B8%9D%E7%9A%84JVM%E5%B7%A5%E5%8E%82%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://jasonsonghoho.github.io/2018/04/15/克拉丝的JVM工厂之旅（上）/</id>
    <published>2018-04-15T02:37:32.000Z</published>
    <updated>2018-09-22T02:52:12.549Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/X_tO5Lgjof_RTlyN_xtSHw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/X_tO5Lgjof_RTlyN_xtSHw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/X_tO5Lgjof_RTlyN_xtSHw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/X_tO5Lgjof_RTly
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="JVM" scheme="https://jasonsonghoho.github.io/public/tags/JVM/"/>
    
      <category term="类加载" scheme="https://jasonsonghoho.github.io/public/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Metric使用</title>
    <link href="https://jasonsonghoho.github.io/2017/12/18/2017-12-18-doc/"/>
    <id>https://jasonsonghoho.github.io/2017/12/18/2017-12-18-doc/</id>
    <published>2017-12-18T14:08:41.000Z</published>
    <updated>2018-09-22T02:49:05.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title=" 目录 (Table of Contents)"></a> <strong>目录 (Table of Contents)</strong></h2><ul><li>简介</li><li>MAVEN设置</li><li>The Registry</li><li>五种度量类型<ul><li>Gauges</li><li>Counters</li><li>Histograms</li><li>Meters</li><li>Timers</li></ul></li><li>Reporter</li><li>健康检查</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Metrics是一个给JAVA提供度量工具的包，在JAVA代码中嵌入Metrics代码，可以方便的对业务代码的各个指标进行监控。<br>Metric 的使用可参考<a href="http://metrics.dropwizard.io/3.2.3/getting-started.html" target="_blank" rel="noopener">官网</a>。</p><h2 id="MAVEN设置"><a href="#MAVEN设置" class="headerlink" title="MAVEN设置"></a>MAVEN设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;dependency&gt; </span><br><span class="line">        &lt;groupId&gt; io.dropwizard.metrics &lt;/ groupId&gt; </span><br><span class="line">        &lt;artifactId&gt; metrics-core &lt;/ artifactId&gt; </span><br><span class="line">        &lt;version&gt; $ &#123;metrics.version&#125; &lt;/ version&gt; </span><br><span class="line">    &lt;/ dependency&gt; </span><br><span class="line">&lt;/ dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="The-Registry"><a href="#The-Registry" class="headerlink" title="The Registry"></a>The Registry</h2><p>Metrics的核心是MetricRegistry类，它是所有应用程序指标的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final MetricRegistry metrics = new MetricRegistry();</span><br></pre></td></tr></table></figure><h2 id="五种度量类型"><a href="#五种度量类型" class="headerlink" title="五种度量类型"></a>五种度量类型</h2><h3 id="Gauges"><a href="#Gauges" class="headerlink" title="Gauges"></a>Gauges</h3><p>最基本的度量指标，返回一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class QueueManager &#123;</span><br><span class="line">    private final Queue queue;</span><br><span class="line"></span><br><span class="line">    public QueueManager(MetricRegistry metrics, String name) &#123;</span><br><span class="line">        this.queue = new Queue();</span><br><span class="line">        metrics.register(MetricRegistry.name(QueueManager.class, name, &quot;size&quot;),</span><br><span class="line">                         new Gauge&lt;Integer&gt;() &#123;</span><br><span class="line">                             @Override</span><br><span class="line">                             public Integer getValue() &#123;</span><br><span class="line">                                 return queue.size();</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测量此量表时，将返回队列中的任务数量。</p><p>在注册表中的每个指标都有一个唯一的名称，例如 “things.count”或”com.example.Thing.latency”。MetricRegistry有一个用于构造这些名字的静态辅助方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MetricRegistry.name(QueueManager.class, &quot;jobs&quot;, &quot;size&quot;)</span><br></pre></td></tr></table></figure><p>它将返回一个类似”com.example.QueueManager.jobs.size”的字符串。</p><h3 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h3><p>Counters只是一个AtomicLong实例的衡量标准。您可以增加或减少其值。例如，我们可能需要一个更有效的方式来衡量队列中待处理的任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final Counter pendingJobs = metrics.counter(name(QueueManager.class, &quot;pending-jobs&quot;));</span><br><span class="line"></span><br><span class="line">public void addJob(Job job) &#123;</span><br><span class="line">    pendingJobs.inc();</span><br><span class="line">    queue.offer(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Job takeJob() &#123;</span><br><span class="line">    pendingJobs.dec();</span><br><span class="line">    return queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次测量这个计数器时，它都会返回队列中的任务数量。</p><p>正如你所看到的，Counters的API略有不同：用 counter(String)而不是 register(String, Metric) 。</p><h3 id="Histograms"><a href="#Histograms" class="headerlink" title="Histograms"></a>Histograms</h3><p>Histograms（直方图 ）统计 数据流中值的分布。除了最小值，最大值，平均值等之外，它还测量中值，第75,90,95,98,99和99.9百分位数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Histogram responseSizes = metrics.histogram(name(RequestHandler.class, &quot;response-sizes&quot;));</span><br><span class="line"></span><br><span class="line">public void handleRequest(Request request, Response response) &#123;</span><br><span class="line">    // etc</span><br><span class="line">    responseSizes.update(response.getContent().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个直方图将以字节为单位来测量响应的大小。</p><h3 id="Meters"><a href="#Meters" class="headerlink" title="Meters"></a>Meters</h3><p>Meters测量一段时间内的事件发生率（例如“每秒请求数”）。除了平均速度之外，Meters还跟踪1，5和15分钟的均值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final MetricRegistry metrics = new MetricRegistry();</span><br><span class="line">private final Meter requests = metrics.meter(&quot;requests&quot;);</span><br><span class="line"></span><br><span class="line">public void handleRequest(Request request, Response response) &#123;</span><br><span class="line">    requests.mark();</span><br><span class="line">    // etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将测量每秒请求的请求率。</p><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>Timer测量一段代码被调用的速率和它的持续时间的分布。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final Timer responses = metrics.timer(name(RequestHandler.class, &quot;responses&quot;));</span><br><span class="line"></span><br><span class="line">public String handleRequest(Request request, Response response) &#123;</span><br><span class="line">    final Timer.Context context = responses.time(); //相当于Meter.mark()</span><br><span class="line">    try &#123;</span><br><span class="line">        // etc;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Timer 将测量处理每个请求所需的时间（以纳秒为单位），并提供每秒请求的请求速率。</p><p>Timer 其实是 Histogram 和 Meter 的结合</p><h2 id="Reporter"><a href="#Reporter" class="headerlink" title="Reporter"></a>Reporter</h2><p>报表，用于展示统计结果</p><ol><li><p>通过JMX报告Metric</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final JmxReporter reporter = JmxReporter.forRegistry(registry).build();</span><br><span class="line">reporter.start();</span><br></pre></td></tr></table></figure></li><li><p>STDOUT, using ConsoleReporter from metrics-core</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final ConsoleReporter reporter = ConsoleReporter.forRegistry(registry)</span><br><span class="line">                                                .convertRatesTo(TimeUnit.SECONDS)</span><br><span class="line">                                                .convertDurationsTo(TimeUnit.MILLISECONDS)</span><br><span class="line">                                                .build();</span><br><span class="line">reporter.start(1, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure></li><li><p>CSV files, using CsvReporter from metrics-core</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final CsvReporter reporter = CsvReporter.forRegistry(registry)</span><br><span class="line">                                        .formatFor(Locale.US)</span><br><span class="line">                                        .convertRatesTo(TimeUnit.SECONDS)</span><br><span class="line">                                        .convertDurationsTo(TimeUnit.MILLISECONDS)</span><br><span class="line">                                        .build(new File(&quot;~/projects/data/&quot;));</span><br><span class="line">reporter.start(1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li><li><p>SLF4J loggers, using Slf4jReporter from metrics-core</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final Slf4jReporter reporter = Slf4jReporter.forRegistry(registry)</span><br><span class="line">                                            .outputTo(LoggerFactory.getLogger(&quot;com.example.metrics&quot;))</span><br><span class="line">                                            .convertRatesTo(TimeUnit.SECONDS)</span><br><span class="line">                                            .convertDurationsTo(TimeUnit.MILLISECONDS)</span><br><span class="line">                                            .build();</span><br><span class="line">reporter.start(1, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure></li><li><p>Ganglia, using GangliaReporter from metrics-ganglia</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final GMetric ganglia = new GMetric(&quot;ganglia.example.com&quot;, 8649, UDPAddressingMode.MULTICAST, 1);</span><br><span class="line">final GangliaReporter reporter = GangliaReporter.forRegistry(registry)</span><br><span class="line">                                                .convertRatesTo(TimeUnit.SECONDS)</span><br><span class="line">                                                .convertDurationsTo(TimeUnit.MILLISECONDS)</span><br><span class="line">                                                .build(ganglia);</span><br><span class="line">reporter.start(1, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure></li><li><p>Graphite, using GraphiteReporter from metrics-graphite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Graphite graphite = new Graphite(new InetSocketAddress(&quot;graphite.example.com&quot;, 2003));</span><br><span class="line">final GraphiteReporter reporter = GraphiteReporter.forRegistry(registry)</span><br><span class="line">                                                  .prefixedWith(&quot;web1.example.com&quot;)</span><br><span class="line">                                                  .convertRatesTo(TimeUnit.SECONDS)</span><br><span class="line">                                                  .convertDurationsTo(TimeUnit.MILLISECONDS)</span><br><span class="line">                                                  .filter(MetricFilter.ALL)</span><br><span class="line">                                                  .build(graphite);</span><br><span class="line">reporter.start(1, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure></li></ol><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>度量标准还能够对服务的健康状况进行检查，需要引用metrics-healthchecks模块 。</p><p>首先，创建一个新的HealthCheckRegistry实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final HealthCheckRegistry healthChecks = new HealthCheckRegistry();</span><br></pre></td></tr></table></figure><p>其次，实现一个HealthCheck子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DatabaseHealthCheck extends HealthCheck &#123;</span><br><span class="line">    private final Database database;</span><br><span class="line"></span><br><span class="line">    public DatabaseHealthCheck(Database database) &#123;</span><br><span class="line">        this.database = database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public HealthCheck.Result check() throws Exception &#123;</span><br><span class="line">        if (database.isConnected()) &#123;</span><br><span class="line">            return HealthCheck.Result.healthy();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return HealthCheck.Result.unhealthy(&quot;Cannot connect to &quot; + database.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用Metrics注册它的一个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">healthChecks.register(&quot;postgres&quot;, new DatabaseHealthCheck(database));</span><br></pre></td></tr></table></figure><p>运行所有注册的健康检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final Map&lt;String, HealthCheck.Result&gt; results = healthChecks.runHealthChecks();</span><br><span class="line">for (Entry&lt;String, HealthCheck.Result&gt; entry : results.entrySet()) &#123;</span><br><span class="line">    if (entry.getValue().isHealthy()) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + &quot; is healthy&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.err.println(entry.getKey() + &quot; is UNHEALTHY: &quot; + entry.getValue().getMessage());</span><br><span class="line">        final Throwable e = entry.getValue().getError();</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>度量标准带有预先构建的运行状况检查：ThreadDeadlockHealthCheck使用Java的内置线程死锁检测来确定是否有线程死锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录-Table-of-Contents&quot;&gt;&lt;a href=&quot;#目录-Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot; 目录 (Table of Contents)&quot;&gt;&lt;/a&gt; &lt;strong&gt;目录 (Table of C
      
    
    </summary>
    
      <category term="中间件" scheme="https://jasonsonghoho.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="java" scheme="https://jasonsonghoho.github.io/public/tags/java/"/>
    
      <category term="Metric" scheme="https://jasonsonghoho.github.io/public/tags/Metric/"/>
    
  </entry>
  
  <entry>
    <title>产品性能自测</title>
    <link href="https://jasonsonghoho.github.io/2017/12/10/171210/"/>
    <id>https://jasonsonghoho.github.io/2017/12/10/171210/</id>
    <published>2017-12-10T14:08:41.000Z</published>
    <updated>2018-09-22T02:46:04.906Z</updated>
    
    <content type="html"><![CDATA[<p>*本文是从公司内网KB转过来的，格式有点混乱懒得改了QAZ~~</p><h2 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title=" 目录 (Table of Contents)"></a> <strong>目录 (Table of Contents)</strong></h2><ul><li>FAQ</li><li>一、测试目的</li><li>二、测试环境</li><li>三、测试方法</li><li>四、测试结果<ul><li>写:</li><li>读：</li></ul></li><li>五、结论<ul><li>1、指标库写性能：</li><li>2、指标库读性能：</li></ul></li></ul><p></p><h2 id="id-指标库性能测试-FAQ">FAQ</h2><p></p><p><strong>1.写入能力：多少个15秒监控周期的主机，或180秒监控周期的网络设备的数据写入</strong></p><br><p style="margin-left: 30.0px;">假设现场1个资源每15 S上报100个指标，则每分钟上报400个，</p><br><p style="margin-left: 30.0px;">若部署单节点Cassandra，在redis集群状况良好的情况下，每分钟可写入80W个指标，可支持800000/400=2000个资源左右;</p><br><p style="margin-left: 30.0px;">若部署Cassandra 集群，每分钟可写入110W个指标，可支持1100000/400=2750个资源左右;</p><br><p style="margin-left: 30.0px;">考虑到稳定性可酌情减少资源量或增加配置。</p><br><p><strong>2.读出能力：每秒完成指定数据点数查询的TPS性能峰值，以便预测可以支持什么数量的仪表盘</strong></p><br><p style="margin-left: 30.0px;">在三台4C*16G的Cassandra节点的配置下，稳定查询的前提下，每分钟至少400条并发请求（每条请求至少6000条元数据，大约为15分钟的数据）。</p><br><p style="margin-left: 30.0px;"></p><br><p></p><br><p></p><br><p></p><br><h2 id="id-指标库性能测试-一、测试目的">一、测试目的</h2><br><p>测试在指定硬件条件下，指标库写入能力与读取能力。</p><br><h2 id="id-指标库性能测试-二、测试环境">二、测试环境</h2><br><div class="table-wrap"><br>    <table class="confluenceTable"><br>        <tbody><br>        <tr><br>            <th class="confluenceTh">ip</th><br>            <th colspan="1" class="confluenceTh">cpu</th><br>            <th class="confluenceTh">内存</th><br>            <th colspan="1" class="confluenceTh">磁盘</th><br>            <th colspan="1" class="confluenceTh">用途</th><br>            <th colspan="1" class="confluenceTh">备注</th><br>        </tr><br>        <tr><br>            <td colspan="1" class="confluenceTd">个人电脑</td><br>            <td colspan="1" class="confluenceTd">4核</td><br>            <td colspan="1" class="confluenceTd">16G</td><br>            <td colspan="1" class="confluenceTd"></td><br>            <td colspan="1" class="confluenceTd"><span>部署jmeter</span></td><br>            <td colspan="1" class="confluenceTd"></td><br>        </tr><br>        <tr><br>            <td colspan="1" class="confluenceTd"><span>10.1.53.37</span></td><br>            <td colspan="1" class="confluenceTd">6<span>核</span></td><br>            <td colspan="1" class="confluenceTd">8G</td><br>            <td colspan="1" class="confluenceTd"></td><br>            <td rowspan="4" class="confluenceTd">部署jmeter-server</td><br>            <td rowspan="4" class="confluenceTd"><p><span>通过jmeter来发送测试请求，</span></p><br>                <p>这些机器同时部署着其他产品。<br><br></p></td><br>        </tr><br>        <tr><br>            <td colspan="1" class="confluenceTd"><span>10.1.53.38</span></td><br>            <td colspan="1" class="confluenceTd"><span>4核</span></td><br>            <td colspan="1" class="confluenceTd">16G</td><br>            <td colspan="1" class="confluenceTd"></td><br>        </tr><br>        <tr><br>            <td colspan="1" class="confluenceTd"><span>10.1.53.65</span></td><br>            <td colspan="1" class="confluenceTd"><span>4核</span></td><br>            <td colspan="1" class="confluenceTd"><span>8G</span></td><br>            <td colspan="1" class="confluenceTd"></td><br>        </tr><br>        <tr><br>            <td colspan="1" class="confluenceTd"><span>10.1.61.10</span></td><br>            <td colspan="1" class="confluenceTd"><span>4核</span></td><br>            <td colspan="1" class="confluenceTd">24G</td><br>            <td colspan="1" class="confluenceTd"></td><br>        </tr><br>        <tr><br>            <td colspan="1" class="confluenceTd">10.1.53.39</td><br>            <td colspan="1" class="confluenceTd"><span>4核</span></td><br>            <td colspan="1" class="confluenceTd">16G</td><br>            <td colspan="1" class="confluenceTd"></td><br>            <td colspan="1" class="confluenceTd">指标库、ES、租户等组件</td><br>            <td colspan="1" class="confluenceTd">该机器主要用来部署指标库</td><br>        </tr><br>        <tr><br>            <td class="confluenceTd">10.1.61.117</td><br>            <td colspan="1" class="confluenceTd">4核</td><br>            <td class="confluenceTd">16G</td><br>            <td colspan="1" class="confluenceTd">38G</td><br>            <td colspan="1" class="confluenceTd">kairosdb、omp等</td><br>            <td colspan="1" class="confluenceTd"><span>kairosdb 堆内存为默认的3g</span></td><br>        </tr><br>        <tr><br>            <td class="confluenceTd">10.1.61.118</td><br>            <td colspan="1" class="confluenceTd">4核</td><br>            <td class="confluenceTd">16G</td><br>            <td colspan="1" class="confluenceTd">38G</td><br>            <td colspan="1" class="confluenceTd">Cassandra</td><br>            <td colspan="1" class="confluenceTd"><p><span>kairosdb 堆内存为<span>为默认的4</span>g，</span></p><br>                <p>计算公式 max(min(1/2 ram, 1024MB),min(1/4 ram, 8GB))</p></td><br>        </tr><br>        </tbody><br>    </table><br></div><br><p></p><br><h2 id="id-指标库性能测试-三、测试方法">三、测试方法</h2><br><p>测试工具为Jmeter，通过调用指标库相应的openApi测试，用jconsole 监控进程占用资源变化。</p><br><h2 id="id-指标库性能测试-四、测试结果">四、测试结果</h2><h4 id="id-指标库性能测试-写:">写:</h4><br><p style="margin-left: 30.0px;"><span>Ramp-up Period <span>决定多长时间启动所有线程。如果使用10个线程，ramp-up period是100秒，那么JMeter用100秒使所有10个线程启动并运行。每个线程会在上一个线程启动后10秒（100/10）启动。</span></span><br></p><br><p style="margin-left: 30.0px;">monitor 指标上报的频率是15S一次，故此处从 以15S/s 的频率启动一个上报线程开始测试。</p><br><p style="margin-left: 30.0px;">如组1，测试逻辑为：</p><br><p style="margin-left: 60.0px;">每15秒启动一个线程，单个线程每次上报25个指标，重复上报500次，每分钟指标写入请求次数为5W条。</p><br><p style="margin-left: 60.0px;">jmeter-server为1，表示只在本机运行测试；若为4，表示在4个机器上同时对指标库发起请求测试。</p><br><p style="margin-left: 30.0px;"></p><br><p></p><br><p></p><br><p style="margin-left: 30.0px;">1.kairosdb 自带写入统计指标：</p><br><p style="margin-left: 60.0px;">kairosdb.metric_counters - Counts the number of data points received since the last<br>    report. Tags are used to separate one metric from another.（统计自上次上报后接收的数据量。标签用于区分指标。）</p><br><p style="margin-left: 60.0px;"></p><br><p style="margin-left: 30.0px;">kairosdb 统计结果：</p><br><p style="margin-left: 30.0px;"><br><img src="/2017/12/10/171210/kairosdb_metric_count.png"><br><br></p><br><p style="margin-left: 30.0px;">“1”处为组别12的测试结果，“2”处为直接调用kairosdb restApi 写入接口，“3”处为组别14 的结果。结果与指标库的统计日志一致。<br><br></p><p style="margin-left: 30.0px;">2.时间有限，每组测试时间间隔较短，因此可能会对CPU、内存以及Cassandra状态产生影响，使结果不够准确。</p><br><p style="margin-left: 30.0px;"></p><br><p style="margin-left: 30.0px;"><strong>注：</strong></p><br><p style="margin-left: 30.0px;">【1】：指标库redis 报内存不够，异常： Can’t save in background: fork: Cannot allocate memory</p><br><p style="margin-left: 30.0px;">【2】：<span style="background-color: transparent;">短时间插入大量指标会导致未压实的sstable数据太多，压实进程报可用磁盘空间不足，重新压实…恶性循环。</span><br></p><br><p style="margin-left: 30.0px;"><span style="background-color: transparent;"><br></span></p><br><div class="code panel pdl" style="border-width: 1px;"><br>    <div class="codeContent panelContent pdl"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[[root@localhost data_points-1e09be40c3c811e7977aa147ea7baf03]# /opt/cassandra/bin/nodetool compactionstats -H</span><br><span class="line">pending tasks: 2</span><br><span class="line">- kairosdb.data_points: 2</span><br><span class="line">id                                   compaction type keyspace table       completed total    unit  progress</span><br><span class="line">ef340e00-d4d8-11e7-a239-0d717928a22e Compaction      kairosdb data_points 6.23 GB   11.42 GB bytes 54.56%</span><br><span class="line">Active compaction remaining time :   0h05m32s</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><br><br>    </div><br></div><br><p style="margin-left: 30.0px;"><span><br></span></p><br><p style="margin-left: 30.0px;"><span>Cassandra报异常:</span></p><br><div class="code panel pdl" style="border-width: 1px;"><br>    <div class="codeContent panelContent pdl"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[WARN  [CompactionExecutor:46] 2017-11-28 22:26:29,785 CompactionTask.java:91 - insufficient space to compact all requested files BigTableReader(path=&amp;#39;/opt/dbdata/cassandra/data/kairosdb/data_points-1e09be40c3c811e7977aa147ea7baf03/ma-216-big-Data.db&amp;#39;), BigTableReader(path=&amp;#39;/opt/dbdata/cassandra/data/kairosdb/data_points-1e09be40c3c811e7977aa147ea7baf03/ma-237-big-Data.db&amp;#39;)</span><br><span class="line">ERROR [CompactionExecutor:46] 2017-11-28 22:26:29,827 CassandraDaemon.java:195 - Exception in thread Thread[CompactionExecutor:46,1,main]</span><br><span class="line">java.lang.RuntimeException: Not enough space for compaction, estimated sstables = 1, expected write size = 2395303467</span><br><span class="line">at org.apache.cassandra.db.compaction.CompactionTask.checkAvailableDiskSpace(CompactionTask.java:278) ~[apache-cassandra-3.5.jar:3.5]</span><br><span class="line">at org.apache.cassandra.db.compaction.CompactionTask.runMayThrow(CompactionTask.java:126) ~[apache-cassandra-3.5.jar:3.5]</span><br><span class="line">at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:28) ~[apache-cassandra-3.5.jar:3.5]</span><br><span class="line">at org.apache.cassandra.db.compaction.CompactionTask.executeInternal(CompactionTask.java:82) ~[apache-cassandra-3.5.jar:3.5]</span><br><span class="line">at org.apache.cassandra.db.compaction.AbstractCompactionTask.execute(AbstractCompactionTask.java:60) ~[apache-cassandra-3.5.jar:3.5]</span><br><span class="line">at org.apache.cassandra.db.compaction.CompactionManager$BackgroundCompactionCandidate.run(CompactionManager.java:264) ~[apache-cassandra-3.5.jar:3.5]</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[na:1.8.0_144]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_144]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[na:1.8.0_144]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_144]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_144]</span><br><span class="line"></span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><br><br>    </div><br></div><br><p></p><br><p style="margin-left: 30.0px;">解决方法：</p><br><p style="margin-left: 60.0px;">1、增大磁盘空间、</p><br><p style="margin-left: 60.0px;">2、直接删除同一编号的sstable 大文件</p><br><p style="margin-left: 60.0px;">3、重装Cassandra</p><h4 id="id-指标库性能测试-多节点写:">多节点写:</h4><br><p style="margin-left: 30.0px;">1.通过观察发现，写的瓶颈在指标库的gateway，然后增加多节点的测试如下：</p><br><ul><br>    <li style="margin-left: 30.0px;">开启一个gateway、一个writer模块后，指标写入能力在 <strong>50W/分钟</strong>；</li><br>    <li style="margin-left: 30.0px;">开启三个gateway、一个writer模块后，指标写入能力在 <strong>80W/分钟</strong>；</li><br>    <li style="margin-left: 30.0px;">开启三个三个gateway、三个writer 模块后，指标写入能力在 <strong>85W/分钟</strong>。</li><br></ul><br><br><p><br><img src="/2017/12/10/171210/kairosdb_metric_count_70W_75W.png"><br><br></p><p style="margin-left: 30.0px;">2.当部署Cassandra集群（3个节点）后，指标写入能力可以再次提升，<span style="background-color: transparent;">开启三个gateway、一个writer模块，指标写入能力在 <strong>100W/分钟</strong> ，此状态下可持续写入四个小时，期间redis会报内存不够的异常。</span><br></p>&lt;p style=”margin-left: 30.0px; &gt;<br><br><br><p></p><p style="margin-left: 30.0px;"><span style="background-color: transparent;">另外，当指标库写入在满载的情况下，指标的读取能力会受到很大影响，且写入也会偶尔报连接超时现象。</span><br></p><br><p style="margin-left: 30.0px;"><span style="background-color: transparent;"><br></span></p><h4 id="id-指标库性能测试-读："><br>    读：</h4><br><p>指标的查询，其实是kairosdb去查Cassandra中数据。因此kairosdb查Cassandra的速度才是关键因素。而查Cassandra数据的速度，跟查询的Cassandra的row数量、元数据量等因素相关。</p><br><p>要模拟读取测试，就需要先调查现场实际查询的row和元数据大小。</p><br><p>统计局的统计如下：</p><br><p style="margin-left: 30.0px;">上图为密集查询30分钟内指标时，从Cassandra中查询的row的行数；</p><br><p style="margin-left: 30.0px;">中图为密集查询30分钟内指标时，从Cassandra中查询的元数据的数量；</p><br><p style="margin-left: 30.0px;">下图为定时查询时row的行数。</p><br><p><br><br></p><br><p style="margin-left: 30.0px;"><br><img src="/2017/12/10/171210/统计局_query_row_count2.png"><br><br></p><br><p style="margin-left: 30.0px;"></p><br><p style="margin-left: 30.0px;"><br><img src="/2017/12/10/171210/统计局_query_sample_size.png"><br><br></p><br><p style="margin-left: 30.0px;"></p><br><p style="margin-left: 30.0px;"><br><img src="/2017/12/10/171210/统计局_query_row_count.png"><br><br></p><br><p style="margin-left: 30.0px;"></p><br><p style="margin-left: 30.0px;"></p><br><p style="margin-left: 30.0px;">可以看出：</p><br><p style="margin-left: 30.0px;">密集查询时，row最大的在4000，大部分比较小，接近1。定时查询时，row在100行以下。</p><br><p style="margin-left: 30.0px;">现场400个设备，查询30分钟指标时，理论上应该有大约400<em>4</em>30=48000 的元数据，实际查询时，要小于该值。基本都在几百条。</p><br><p></p><br><p></p><p></p><p style="margin-left: 30.0px;">过程：</p><p></p><ol><br>    <li>可以看到单Cassandra节点下，kairosdb查询Cassandra最短耗时已经在2S左右，而集群模式下，kairosdb查询Cassandra的最短耗时在200ms<br>        左右，可以看出在低硬件配置下，Cassandra部署集群模式比单机模式的性能提升很大。<br>    </li><br>    <li>Cassandra刚部署时，查询性能表现优秀，连续写入一个小时数据后，查询性能下降。</li><br>    <li>2-5组发现kairosdb 查询时间正常， 但指标库查询出现超时，经建飞排查，原因是调用kairosdb client时创建的 http连接 最大数量最2，修改为200后，情况好转。<br><br><br><br>  <img src="/2017/12/10/171210/image2017-12-8_11_24_9.png"><br><br>    </li><br>    <li>从测试过程可以看到，部分指标库的查询耗时比kairosdb查Cassandra的耗时长很多，查询kairosdb.datastore.queries_waiting<br>        指标，发现kairosdb存在大量等待线程。如下：<br><br><br><br><img src="/2017/12/10/171210/kairosdb.datastore.queries_waiting.png"><br><br>          <br>修改<br>        kairosdb 的配置：kairosdb.datastore.concurrentQueryThread ，再次查询，依然会有等待的查询线程。<br>据此判断，当查询15个指标时，每个指标耗时在2.5S左右时，此硬件配置下的kairosdb性能已达瓶颈，影响因素为CPU核数。当更改部署kairosdb<br>        机器的核数后，性能得到了提升。<br>    </li><br>    <li>同样的查询条件下，CPU核数与kairosdb 的concurrentQueryThread 参数一致时，性能最优；且该参数只在kairosdb 查Cassandra较慢（2S以上）时，才会产生影响。</li><br></ol><br><h2 id="id-指标库性能测试-五、结论"><br>五、结论</h2><br><h3 id="id-指标库性能测试-1、指标库写性能：">1、指标库写性能：</h3><br><ol><br>    <li>由3、5、6组可知，每分钟请求总量一定的情况下，在未到达瓶颈前，并发线程越多，指标写入量越大。</li><br>    <li>由6、8组可知，本机的机器性能并未成为影响指标写入的因素。</li><br>    <li>由6、7和8、9两组可知，在4核16G单节点Cassandra 配置下，请求数在50W/min 左右时，指标库的gateway 模块接收请求已到达瓶颈，为 <strong>50W /min</strong> 左右。</li><br>    <li>由9、10、11三组可知，在指标写入能力到达瓶颈后，改变并发的线程数，不再产生影响。</li><br>    <li>由9、12组可知，待写入的指标类型量不是影响因素。</li><br>    <li>由15组可知，当指标库写入请求量每分钟到千万级时，会出现redis 内存问题。</li><br>    <li>单指标库、单Cassandra节点下，指标写入能力瓶颈在Cassandra处，为 <strong>80W/min</strong>；<br>多指标库、单Cassandra节点下，指标写入能力瓶颈在Cassandra处，为<br>        <strong>85W/min</strong>；<br>单指标库、多Cassandra节点下，指标写入能力瓶颈为 <strong>100W/min</strong>；<br>多指标库、多Cassandra节点下，指标写入能力瓶颈为<strong><br>            <strong>110W/min</strong></strong>。<br><br><br></li><br></ol><br><p></p><br><p>配置预估：</p><br><p style="margin-left: 30.0px;">假设现场1个资源每15 S上报100个指标，则每分钟上报400个，若采用单节点Cassandra<br>    配置，在redis集群状况良好的情况下，可支持1750个资源左右，考虑到稳定性可酌情减少资源量或增加配置。</p><br><p style="margin-left: 30.0px;"></p><br><h3 id="id-指标库性能测试-2、指标库读性能：">2、指标库读性能：</h3><br><ol><br>    <li>由1、2组可知R12版本指标库在现有配置下，最多支持每分钟30次的查询。</li><br>    <li>由2、3组可知，查询较慢时，每10S钟查询10次，比每5S钟查询5次，查询要快。</li><br>    <li>由2、4组可知，相同的请求量下，同一个指标密集查询2次，比两个指标同时各查一次要慢很多。</li><br>    <li>由1、5组可知，查询的数据量从600到7200，查询的Cassandra row从 77到740，查询耗时基本没有变化，不过Cassandra的资源消耗增加很多。</li><br>    <li>由2、7组可知，kairosdb client 创建的 http连接 最大数量与查询性能十分相关，R13中已调整该参数为200。</li><br>    <li>由6-8、14、15组可知，单Cassandra节点下，指标查询的瓶颈为 <strong>90次/分钟</strong>，且当 指标库的查询耗时 与<br>        kairosdb查Cassandra的耗时相差不大时，可以维持稳定查询状态，否则指标库查询超时会越来越严重。<br>    </li><br>    <li>由8-13、17-19组可知，kairosdb的concurrentQueryThread 参数值与CPU核数一致时，性能最优；且该参数只在kairosdb 查Cassandra较慢（2S以上）时，才会产生影响。</li><br>    <li>由8、16组可知，指标库是否集群模式不是瓶颈。</li><br>    <li>由19、22和20、23两组可知，单kairosdb 8核的查询性能 与双kairosdb 4核基本相同，所以kairosdb 的查询性能与机器的CPU核数有关。</li><br>    <li>由19、24组可知，当前的查询瓶颈在Cassandra 处，Cassandra 集群的查询性能是单节点的10倍。</li><br>    <li>由24-29组可知，Cassandra集群下，查询性能瓶颈为<strong>1400次/分钟</strong>，当查询到1500次/分钟时，kairosdb出现瓶颈，等待查询线程不断增加。</li><br>    <li>由30、31组可知，当Cassandra写入一段时间数据后，指标查询性能下降很多。</li><br></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;*本文是从公司内网KB转过来的，格式有点混乱懒得改了QAZ~~&lt;/p&gt;
&lt;h2 id=&quot;目录-Table-of-Contents&quot;&gt;&lt;a href=&quot;#目录-Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot; 目录 (Table of
      
    
    </summary>
    
      <category term="未分类" scheme="https://jasonsonghoho.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="cassandra" scheme="https://jasonsonghoho.github.io/public/tags/cassandra/"/>
    
      <category term="kairosdb" scheme="https://jasonsonghoho.github.io/public/tags/kairosdb/"/>
    
      <category term="jmeter" scheme="https://jasonsonghoho.github.io/public/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>linux 进程 性能监控</title>
    <link href="https://jasonsonghoho.github.io/2017/11/08/171108/"/>
    <id>https://jasonsonghoho.github.io/2017/11/08/171108/</id>
    <published>2017-11-08T14:08:41.000Z</published>
    <updated>2018-09-20T15:46:06.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>进行性能测试，需要统计 kairosdb 的性能随时间的变化情况。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑过以下方法<br>sar 命令：可以检测机器的各项性能，但不能看进程的性能占用信息<br>top：可以监控到进程的性能信息，但没有趋势图<br>jvisualvm：可以监控到进程的性能信息，有趋势图；但可监控的时间范围受限、不能统计各项状态信息。如下：</p><img src="/2017/11/08/171108/19_14_27.png" title="jvisualvm"><p>最终发现jconsole 可以完美实现这个需求。之前只是感觉jconsoleg功能不如jvisualvm强大，所以没有去看…</p><h2 id="jconsole-使用方法："><a href="#jconsole-使用方法：" class="headerlink" title="jconsole 使用方法："></a>jconsole 使用方法：</h2><ol><li><p>修改远程机器JDK配置文件 (我这里远程机器是linux).<br>a.进入JAVA_HOME\jre\lib\management\目录<br>b.拷贝jmxremote.password.template这个文件到当前目录, 并改名为 jmxremote.password<br>  c.打开jmxremote.password文件，去掉 # monitorRole  QED 和 # controlRole  R&amp;D 这两行前面的注释符号</p></li><li><p>修改远程机器上需要被监控的程序的启动脚本：</p><p> <code>JAVA_OPTS=&quot;-Djava.rmi.server.hostname=10.1.61.117 -Dcom.sun.management.jmxremote.port=18999  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.management.jmxremote.authenticate=false&quot;</code></p><p> 启动脚本 的java 命令后加上 $JAVA_OPTS 参数。</p></li><li><p>本地建立连接，如下：</p></li></ol><img src="/2017/11/08/171108/19_23_5.png" title="本地建立连接"><p>界面如下：</p><img src="/2017/11/08/171108/19_28_49.png" title="界面"><p>更多功能可自行尝试</p><p>可以保存统计数据 到本地(CSV 文件)，如下：</p><img src="/2017/11/08/171108/19_29_20.png" title="保存统计数据"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需求解决 （真是踏破铁鞋无觅处…）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;进行性能测试，需要统计 kairosdb 的性能随时间的变化情况。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=
      
    
    </summary>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/categories/Linux/"/>
    
    
      <category term="踩坑记" scheme="https://jasonsonghoho.github.io/public/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
      <category term="java" scheme="https://jasonsonghoho.github.io/public/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Telnet 命令</title>
    <link href="https://jasonsonghoho.github.io/2017/10/23/171023/"/>
    <id>https://jasonsonghoho.github.io/2017/10/23/171023/</id>
    <published>2017-10-23T14:08:41.000Z</published>
    <updated>2018-09-22T02:45:28.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title=" 目录 (Table of Contents)"></a> <strong>目录 (Table of Contents)</strong></h2><div class="markdown-toc editormd-markdown-toc"><ul class="markdown-toc-list"><li><a class="toc-level-2" href="#login" level="2">login</a></li><li><a class="toc-level-2" href="#status" level="2">status</a></li><li><a class="toc-level-2" href="#ls" level="2">ls</a></li><li><a class="toc-level-2" href="#ps" level="2">ps</a></li><li><a class="toc-level-2" href="#trace" level="2">trace</a></li><li><a class="toc-level-2" href="#invoke" level="2">invoke</a></li><li><a class="toc-level-2" href="#more" level="2">more</a><ul></ul></li></ul></div><blockquote><p>从 2.0.5 版本开始，dubbo 开始支持通过 telnet 命令来镜像服务治理。</p></blockquote><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>telnet localhost 20880(dubbo或服务端口)</p><img src="/2017/10/23/171023/login.png" title="login"><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><ol><li>status: 显示汇总状态，该状态将汇总所有资源的状态，当全部 OK 时则显示 OK，只要有一个 ERROR 则显示 ERROR，只要有一个 WARN 则显示 WARN</li><li>status -l: 显示状态列表</li></ol><p>见上图</p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>显示服务列表、方法列表、参数等</p><ol><li>ls: 显示服务列表</li><li>ls -l: 显示服务详细信息列表</li><li>ls XxxService: 显示服务的方法列表</li><li>ls -l XxxService: 显示服务的方法详细信息列表</li></ol><img src="/2017/10/23/171023/ps&ls.png" title="ls"><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>显示服务端口列表，可用来查看服务是否已成功注册</p><ol><li>ps: 显示服务端口列表</li><li>ps -l: 显示服务地址列表</li><li>ps 20880: 显示端口上的连接信息</li><li>ps -l 20880: 显示端口上的连接详细信息</li></ol><p>见上图</p><h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>跟踪服务任意方法的调用情况</p><ol><li>trace XxxService: 跟踪 1 次服务任意方法的调用情况</li><li>trace XxxService 10: 跟踪 10 次服务任意方法的调用情况</li><li>trace XxxService xxxMethod: 跟踪 1 次服务方法的调用情况</li><li>trace XxxService xxxMethod 10: 跟踪 10 次服务方法的调用情况</li></ol><img src="/2017/10/23/171023/trace.png" title="trace"><h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><p>调用服务的方法，通过该命令可直接调试方法。</p><ol><li>invoke XxxService.xxxMethod({“prop”: “value”}): 调用服务的方法</li><li>invoke xxxMethod({“prop”: “value”}): 调用服务的方法(自动查找包含此方法的服务)</li></ol><img src="/2017/10/23/171023/invoke.png" title="invoke"><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>更多 Dubbo Telnet 命令请参阅：<a href="https://dubbo.gitbooks.io/dubbo-user-book/references/telnet.html" target="_blank" rel="noopener">Telnet 命令参考手册</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录-Table-of-Contents&quot;&gt;&lt;a href=&quot;#目录-Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot; 目录 (Table of Contents)&quot;&gt;&lt;/a&gt; &lt;strong&gt;目录 (Table of C
      
    
    </summary>
    
      <category term="中间件" scheme="https://jasonsonghoho.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="dubbo" scheme="https://jasonsonghoho.github.io/public/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Cassandra 常用命令合集</title>
    <link href="https://jasonsonghoho.github.io/2017/10/22/171022/"/>
    <id>https://jasonsonghoho.github.io/2017/10/22/171022/</id>
    <published>2017-10-22T14:08:41.000Z</published>
    <updated>2018-09-22T02:45:28.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title=" 目录 (Table of Contents)"></a> <strong>目录 (Table of Contents)</strong></h2><div class="markdown-toc editormd-markdown-toc"><ul class="markdown-toc-list"><li><a class="toc-level-2" href="#修改Cassandra 最大可用内存大小" level="2">修改Cassandra 最大可用内存大小</a></li><li><a class="toc-level-2" href="#登录CQL" level="2">登录CQL</a></li><li><a class="toc-level-2" href="#查看墓碑数据总量" level="2">查看墓碑数据总量</a></li><li><a class="toc-level-2" href="#修复表" level="2">修复表</a></li><li><a class="toc-level-2" href="#压实数据" level="2">压实数据</a></li><li><a class="toc-level-2" href="#查看当前压实操作状态和历史压实纪录" level="2">查看当前压实操作状态和历史压实纪录</a></li><li><a class="toc-level-2" href="#查看表的状态" level="2">查看表的状态</a></li><li><a class="toc-level-2" href="#Cassandra 线程池的使用统计信息" level="2">Cassandra 线程池的使用统计信息</a></li><li><a class="toc-level-2" href="#其他" level="2">其他</a><ul></ul></li></ul></div><blockquote><p>文中Cassandra 安装在/opt 目录下，具体执行命令需根据自己的Cassandra安装目录进行调整。<br>Cassandra 版本为 3.5。</p></blockquote><h2 id="修改Cassandra-最大可用内存大小"><a href="#修改Cassandra-最大可用内存大小" class="headerlink" title="修改Cassandra 最大可用内存大小"></a>修改Cassandra 最大可用内存大小</h2><p>Cassandra 默认最大可用内存和初始内存大小(-Xmx 、-Xms )为 4G ，通常情况下偏小。</p><p>修改最大内存大小可直接修改 cassandra/conf/cassandra-env.sh 中 MAX_HEAP_SIZE 参数：<code>MAX_HEAP_SIZE=&quot;4G&quot;</code></p><p>cassandra 有两种GC策略，系统内存在14G以上，推荐使用 G1策略。默认使用的是CMS策略。参阅<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsTuneJVM.html" target="_blank" rel="noopener">Tuning Java resources </a></p><h2 id="登录CQL、查看版本"><a href="#登录CQL、查看版本" class="headerlink" title="登录CQL、查看版本"></a>登录CQL、查看版本</h2><p>登录：<br><code>/opt/cassandra/bin/cqlsh [ip] -u [username] -p [passwd]</code></p><p>查看版本：<br><code>cqlsh&gt;show version</code></p><img src="/2017/10/22/171022/logIn_showVersion.png" title="登录CQL、查看版本"><h2 id="查看墓碑数据总量"><a href="#查看墓碑数据总量" class="headerlink" title="查看墓碑数据总量"></a>查看墓碑数据总量</h2><p>没有直接查看墓碑数量的好方法，可在CQL 中开启tracing，执行查询时，会提示具体表含有多少墓碑数据：</p><img src="/2017/10/22/171022/count_tombstone.png" title="墓碑数据总量"><h2 id="修复表"><a href="#修复表" class="headerlink" title="修复表"></a>修复表</h2><p>修复表可以手动同步各个节点的数据（包括墓碑数据），需在各个节点分别执行</p><p><code>/opt/cassandra/bin/nodetool  repair kairosdb string_index;</code></p><h2 id="压实数据"><a href="#压实数据" class="headerlink" title="压实数据"></a>压实数据</h2><p>墓碑数据过多会影响Cassandra性能。压实数据，可消除墓碑数据。压实前，需进行表数据的修复，以防删除数据恢复。</p><ol><li>手动压实：</li></ol><p><code>/opt/cassandra/bin/nodetool  compact  kairosdb string_index</code></p><ol start="2"><li><p>开启自动压实(默认已开启)：<code>/opt/cassandra/bin/nodetool enableautocompaction</code></p></li><li><p>修改表的压实策略：</p></li></ol><p><code>ALTER TABLE kairosdb.string_index   WITH compaction =   {&#39;class&#39; : &#39;SizeTieredCompactionStrategy&#39;, &#39;min_threshold&#39; : 6 };</code></p><ol start="4"><li>修改自动压实周期：</li></ol><p>默认压实时间为864000，即10天，修改为一天：<code>alter table kairosdb.string_index with GC_GRACE_SECONDS = 86400;</code></p><p>关于压实策略，请参阅：<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html" target="_blank" rel="noopener">How is data maintained</a></p><h2 id="查看当前压实操作状态和历史压实纪录"><a href="#查看当前压实操作状态和历史压实纪录" class="headerlink" title="查看当前压实操作状态和历史压实纪录"></a>查看当前压实操作状态和历史压实纪录</h2><p><code>/opt/cassandra/bin/nodetool  compactionstats;/opt/cassandra/bin/nodetool  compactionhistory;</code></p><img src="/2017/10/22/171022/compaction.png" title="compaction"><h2 id="查看表的状态"><a href="#查看表的状态" class="headerlink" title="查看表的状态"></a>查看表的状态</h2><p><code>/opt/cassandra/bin/nodetool  cfstats kairosdb.data_points  或/opt/cassandra/bin/nodetool  tablestats kairosdb.data_points;</code></p><img src="/2017/10/22/171022/cfstats.png" title="cfstats"><h2 id="Cassandra-线程池的使用统计信息"><a href="#Cassandra-线程池的使用统计信息" class="headerlink" title="Cassandra 线程池的使用统计信息"></a>Cassandra 线程池的使用统计信息</h2><p>Cassandra基于分阶段事件驱动架构（SEDA）。Cassandra将不同的任务分成由消息服务连接的很多阶段。每个阶段都有一个队列和一个线程池。如果下一个阶段太忙，Cassandra会备份队列，并将导致性能瓶颈。</p><p><code>/opt/cassandra/bin/nodetool tpstats;</code></p><img src="/2017/10/22/171022/tpstats.png" title="tpstats"><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更多 cassandra命令请参阅：<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/tools/toolsNodetool.html" target="_blank" rel="noopener">The nodetool utility</a> 、<a href="https://docs.datastax.com/en/cassandra/3.0/index.html" target="_blank" rel="noopener">Apache Cassandra</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录-Table-of-Contents&quot;&gt;&lt;a href=&quot;#目录-Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot; 目录 (Table of Contents)&quot;&gt;&lt;/a&gt; &lt;strong&gt;目录 (Table of C
      
    
    </summary>
    
      <category term="数据库" scheme="https://jasonsonghoho.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="cassandra" scheme="https://jasonsonghoho.github.io/public/tags/cassandra/"/>
    
      <category term="cql" scheme="https://jasonsonghoho.github.io/public/tags/cql/"/>
    
  </entry>
  
  <entry>
    <title>记一次store 指标库 线上故障的排查</title>
    <link href="https://jasonsonghoho.github.io/2017/09/28/170928/"/>
    <id>https://jasonsonghoho.github.io/2017/09/28/170928/</id>
    <published>2017-09-28T14:08:41.000Z</published>
    <updated>2018-09-20T15:23:28.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title=" 目录 (Table of Contents)"></a> <strong>目录 (Table of Contents)</strong></h2><div class="markdown-toc editormd-markdown-toc"><ul class="markdown-toc-list"><li><a class="toc-level-2" href="#环境" level="2">环境</a></li><li><a class="toc-level-2" href="#问题&amp;分析&amp;解决" level="2">问题&amp;分析&amp;解决</a><ul><li><a class="toc-level-4" href="#问题1" level="4">问题1</a></li><li><a class="toc-level-4" href="#分析" level="4">分析</a></li><li><a class="toc-level-4" href="#解决" level="4">解决</a></li><li><a class="toc-level-4" href="#问题2" level="4">问题2</a></li><li><a class="toc-level-4" href="#分析" level="4">分析</a></li><li><a class="toc-level-4" href="#解决" level="4">解决</a></li><li><a class="toc-level-4" href="#其他问题" level="4">其他问题</a></li><li><a class="toc-level-4" href="#分析&amp;解决" level="4">分析&amp;解决</a></li></ul></li><li><a class="toc-level-2" href="#其他" level="2">其他</a></li><li><a class="toc-level-2" href="#资料" level="2">资料</a><ul></ul></li></ul></div><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>统计局，三个节点配置一样：</p><ul><li>内存：500+G</li><li>CPU：4*13 core</li></ul><p>Cassandra 、kaiorsdb  、指标库都是以集群模式部署在三台机器上。</p><h2 id="问题-amp-分析-amp-解决"><a href="#问题-amp-分析-amp-解决" class="headerlink" title="问题&amp;分析&amp;解决"></a>问题&amp;分析&amp;解决</h2><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>统计局 monitor线上环境 统计报表和仪表盘部分加载缓慢，加载时间在8秒左右。</p><img src="/2017/09/28/170928/load_time.png" title="加载时间1"><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>首先看了指标库的reader 模块日志，发现query 大量timeout异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17-09-22 14:12:29.208 WARN  [DubboServerHandler-10.6.143.124:7513-thread-576] [c.a.d.rpc.filter.TimeoutFilter]  [DUBBO] invoke time out. method: queryarguments: [e10adc3949ba59abbe56e057f20f88dd, DatapointQuery&#123;metric=&apos;system.mem.pct_usage&apos;, time=DatapointQueryTime&#123;start=1506060435275, end=1506060735275, interval=1, interval_unit=&apos;seconds&apos;, aggregator=AVG, align_start_time=false, align_sampling=false&#125;, tags=&#123;tenantId=e10adc3949ba59abbe56e057f20f88dd&#125;, groupBy=DatapointQueryGroupBy&#123;tagKeys=[object]&#125;, useCache=false&#125;] , url is dubbo://10.6.143.124:7513/uyun.indian.reader.api.ReaderService?anyhost=true&amp;application=indian-reader&amp;default.accepts=1000&amp;default.threadpool=cached&amp;default.threads=500&amp;default.timeout=5000&amp;dubbo=2.8.4.170831&amp;generic=false&amp;interface=uyun.indian.reader.api.ReaderService&amp;methods=queryByResId,query,queryAllMetrics,queryTags&amp;pid=20707&amp;revision=api&amp;serialization=kryo&amp;side=provider&amp;timestamp=1505982696415, invoke elapsed 6361 ms., dubbo version: 2.8.4.170831, current host: 10.6.143.124</span><br><span class="line">17-09-22 14:13:00.201 WARN  [DubboServerHandler-10.6.143.124:7513-thread-568] [c.a.d.rpc.filter.TimeoutFilter]  [DUBBO] invoke time out. method: queryAllMetricsarguments: [e10adc3949ba59abbe56e057f20f88dd] , url is dubbo://10.6.143.124:7513/uyun.indian.reader.api.ReaderService?anyhost=true&amp;application=indian-reader&amp;default.accepts=1000&amp;default.threadpool=cached&amp;default.threads=500&amp;default.timeout=5000&amp;dubbo=2.8.4.170831&amp;generic=false&amp;interface=uyun.indian.reader.api.ReaderService&amp;methods=queryByResId,query,queryAllMetrics,queryTags&amp;pid=20707&amp;revision=api&amp;serialization=kryo&amp;side=provider&amp;timestamp=1505982696415, invoke elapsed 6939 ms., dubbo version: 2.8.4.170831, current host: 10.6.143.124</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>query 使用的 kairosdb的读方法。<a href="https://github.com/kairosdb/kairosdb/wiki/Query-Performance" target="_blank" rel="noopener">kairosdb wiki</a>上指出，当指标的 tag/value 组合太大时，查询时将变得非常缓慢。<br>而monitor报表 每次查询需要汇聚一天的数据。一天的指标数据量和读取时间如下：</p><p>一种解决方法是使用<a href="https://github.com/zachm/tscached" target="_blank" rel="noopener">TScached</a>进行读取，tscached 是kairosdb 的一个缓存代理，加载速度可以是kairosdb的100倍（这是它自己说的，感觉有点夸张了）。<br>指标库之前已经配置过 TScached，后来停用了。重新启用后，报表的加载速度明显加快，不再报超时。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">17-09-28 10:01:26.123 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] ********************* start report 2017-09-28 09:56:26 to 2017-09-28 10:01:26 *********************</span><br><span class="line">17-09-28 10:01:26.131 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] methodName=uyun.indian.reader.impl.KairosdbReader, count=320, min=16ms, max=1496ms, avg=116.33ms, median=66.00ms, p75=156.00ms, p95=278.95ms, p99=889.79ms</span><br><span class="line">17-09-28 10:01:26.133 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] methodName=uyun.indian.reader.impl.ReaderServiceImpl.query, count=592, min=16ms, max=1732ms, avg=105.24ms, median=62.00ms, p75=105.00ms, p95=276.05ms, p99=936.27ms</span><br><span class="line">17-09-28 10:01:26.133 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] methodName=uyun.indian.reader.impl.ReaderServiceImpl.queryAllMetrics, count=1, min=4ms, max=4ms, avg=4.00ms, median=4.00ms, p75=4.00ms, p95=4.00ms, p99=4.00ms</span><br><span class="line">17-09-28 10:01:26.134 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] methodName=uyun.indian.reader.impl.ReaderServiceImpl.queryByResId, count=2, min=2ms, max=40ms, avg=21.00ms, median=21.00ms, p75=40.00ms, p95=40.00ms, p99=40.00ms</span><br><span class="line">17-09-28 10:01:26.134 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] methodName=uyun.indian.reader.impl.ReaderServiceImpl.queryTags, count=4, min=37ms, max=38ms, avg=37.50ms, median=37.50ms, p75=38.00ms, p95=38.00ms, p99=38.00ms</span><br><span class="line">17-09-28 10:01:26.135 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] methodName=uyun.indian.reader.impl.TScachedReader, count=272, min=22ms, max=1732ms, avg=91.88ms, median=57.00ms, p75=75.75ms, p95=241.05ms, p99=1092.88ms</span><br><span class="line">17-09-28 10:01:26.135 INFO  [reporter-thread-1   ] [u.i.method.elapsedtime.report ] ********************* end report *********************</span><br></pre></td></tr></table></figure><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>query 方法速度上来之后，发现queryAllMetrics 方法出现超时现象，按问题1的解决办法处理后，发现仍有问题，后改用读redis 缓存的方式后，暂时解决。<br>但Cassandra的资源消耗仍比较大</p><img src="/2017/09/28/170928/cassandra1.png" title="Cassandra 资源消耗"><img src="/2017/09/28/170928/cassandra2.png" title="Cassandra 资源消耗"><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>查看Cassandra system日志后发现 kairosdb.data_points 表中存在大量<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlAboutDeletes.html" target="_blank" rel="noopener">tombstone</a>(墓碑)数据警告，严重影响了Cassandra性能。需对Cassandra 进行数据<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html" target="_blank" rel="noopener">compact</a>(压实)操作，以清除墓碑数据。<br>在对数据进行压实操作之前，需要先<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsRepairNodesManualRepair.html" target="_blank" rel="noopener">repair</a>(修复)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN  [SharedPool-Worker-30] 2017-09-26 15:48:50,818 ReadCommand.java:481 - Read 1024 live rows and 22072 tombstone cells for query SELECT value FROM kairosdb.data_points WHERE key = 65313061646333393439626135396162626535366530353766323066383864647e73797374656d2e6e65742e62797465735f72637664000000015dc970d000000d6b6169726f735f646f75626c656465766963653d6962313a686f73743d646d3031646261646d30342e73746174732e676f762e636e3a69703d31302e362e3133342e38303a6f626a6563743d3539383763643931633633396438613830633433653631383a74656e616e7449643d65313061646333393439626135396162626535366530353766323066383864643a AND column1 &gt;= 00000000 AND column1 &lt;= 9dd94 (see tombstone_warn_threshold)</span><br></pre></td></tr></table></figure><blockquote><p>在Cassandra中，一切都是写入，包括逻辑删除数据，当你删除一条数据时，其实是给这条数据进行update，给它update上一个标识，就是一个墓碑标识。 当Cassandra集群在不同节点之间同步删除信息的时候，也会用到Tombstones(墓碑)，可以说墓碑是一种允许Cassandra快速写入的机制。 </p></blockquote><p>关于Cassandra 如何维护数据，可参考  <a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html" target="_blank" rel="noopener">Cassandra 数据维护官方文档</a></p><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>具体压实步骤如下：</p><ol><li>cassandra 默认压缩周期为10天，首先将压缩周期设为1天，设置 gc_grace_seconds 参数，</li></ol><p>登录Cassandra:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cqlsh host -u user -p pswd</span><br></pre></td></tr></table></figure><p>设置kairosdb的表的压缩周期设为 一天（86400 s）: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table kairosdb.string_index with gc_grace_seconds = 86400;alter table kairosdb.data_points with GC_GRACE_SECONDS = 86400;alter table kairosdb.row_key_index with GC_GRACE_SECONDS = 86400;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">设置完后 ，运行`DESC kairosdb;`，可以看到 **gc_grace_seconds**已被设为86400；</span><br></pre></td></tr></table></figure><p>CREATE TABLE kairosdb.string_index (<br>    key blob,<br>    column1 text,<br>    value blob,<br>    PRIMARY KEY (key, column1)<br>) WITH COMPACT STORAGE<br>    AND CLUSTERING ORDER BY (column1 ASC)<br>    AND bloom_filter_fp_chance = 0.01<br>    AND caching = {‘keys’: ‘ALL’, ‘rows_per_partition’: ‘NONE’}<br>    AND comment = ‘’<br>    AND compaction = {‘class’: ‘org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy’, ‘max_threshold’: ‘32’, ‘min_threshold’: ‘4’}<br>    AND compression = {‘chunk_length_in_kb’: ‘64’, ‘class’: ‘org.apache.cassandra.io.compress.LZ4Compressor’}<br>    AND crc_check_chance = 1.0<br>    AND dclocal_read_repair_chance = 0.1<br>    AND default_time_to_live = 0<br>     AND gc_grace_seconds = 86400<br>    AND max_index_interval = 2048<br>    AND memtable_flush_period_in_ms = 0<br>    AND min_index_interval = 128<br>    AND read_repair_chance = 1.0<br>    AND speculative_retry = ‘NONE’;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2.  为了统一各个节点的墓碑数据，需在各个节点上分别运行修复kairosdb下各个表，防止已删除数据重生;</span><br></pre></td></tr></table></figure><p>nodetool  repair kairosdb row_key_index<br>nodetool  repair kairosdb string_index<br>nodetool  repair kairosdb data_points<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*此处运行修复时，三个节点的data_points表由于数据太大，一直没有完全修复成功（some repair failed ）。由于数据量较大，且接受删掉的数据再次恢复，此处采取的措施是忽略该表。</span><br><span class="line"></span><br><span class="line">3.  修复完后再分别进行压实操作:</span><br></pre></td></tr></table></figure></p><p>nodetool  compact  kairosdb row_key_index<br>nodetool  compact  kairosdb string_index<br>nodetool  compact  kairosdb data_points<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">压实操作可用`nodetool  compactionstats` 和 `nodetool  compactionhistory`分别查看当前和历史的压实造作;</span><br><span class="line"></span><br><span class="line">&#123;% asset_img compactionstats.png 压实状态 %&#125;</span><br><span class="line"></span><br><span class="line">4.  开启自动压实操作（默认已开启）：`nodetool enableautocompaction` </span><br><span class="line"></span><br><span class="line">操作完后，Cassandra 会自动压缩一些其他表的数据。结束后，Cassandra 日志中data_points表 墓碑警告记录墓碑数量大幅变小，可以发现Cassandra对资源的占用变到正常水平。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 其他问题</span><br><span class="line"></span><br><span class="line">1.  cassandra 日志报：</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line"> INFO  [IndexSummaryManager:1] 2017-09-28 08:16:56,278 IndexSummaryRedistribution.java:74 - Redistributing index summaries</span><br><span class="line"> INFO  [SharedPool-Worker-1] 2017-09-28 08:19:46,973 NoSpamLogger.java:91 - Maximum memory usage reached (536870912 bytes), cannot allocate chunk of 1048576 bytes</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">2.  Dubbo 消费者报：No provider available for the service。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 分析&amp;解决</span><br><span class="line"></span><br><span class="line">1.  调查得知，原因是file_cache_size_in_mb较小，文档中描述该参数是用来读[SSTables](https://stackoverflow.com/questions/2576012/what-is-an-sstable)(Sorted Strings Table , is a file of key/value string pairs, sorted by keys)的缓冲区：</span><br><span class="line">&gt;file_cache_size_in_mb :(Default: Smaller of 1/4 heap or 512) Total memory to use for SSTable-reading buffers.</span><br><span class="line"></span><br><span class="line">调到1024 （M）后，不再报该问题</span><br><span class="line"></span><br><span class="line">2.  服务注册不到zookeeper 上，猜测可能是机器IO负载太大。</span><br><span class="line">执行`netstat -nat | awk &apos;&#123;print $6&#125;&apos; | sort | uniq -c | sort -n` ，可以看到 CLOSE_WAIT 连接太多：</span><br></pre></td></tr></table></figure></p><p>[root@Uyun-DB2 logs]# netstat -nat | awk ‘{print $6}’ | sort | uniq -c | sort -n<br>      1 established)<br>      1 Foreign<br>      2 TIME_WAIT<br>     47 LISTEN<br>   1088 ESTABLISHED<br>   3314 CLOSE_WAIT<br><code>`</code></p><p><code>netstat -nat | grep CLOSE_WAIT</code> 后，发现是kairosdb 造成的（猜测是之前Cassandra负载太大造成 ），强行重启kairosdb 后，再启动指标库，服务正常。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>kairosDB 作者建议采用<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html#dmlHowDataMaintain__dtcs-compaction" target="_blank" rel="noopener">DateTieredCompactionStrategy</a> (DTCS)压实策略，参考 <a href="https://github.com/kairosdb/kairosdb/issues/23" target="_blank" rel="noopener">kairosDB Issue 23</a>。需要进一步研究。</p></li><li><p>还是会有 Cassandra 占CPU较高的现象，但日志正常，需要进一步研究。</p></li></ol><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html" target="_blank" rel="noopener">Cassandra–How is data maintained</a></p><p><a href="http://blog.csdn.net/nangongyanya/article/details/54018104" target="_blank" rel="noopener">操作Cassandra（3）-合并、压实</a></p><p><a href="http://www.cnblogs.com/didda/p/4728588.html" target="_blank" rel="noopener">Cassandra 的压缩策略STCS，LCS 和 DTCS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录-Table-of-Contents&quot;&gt;&lt;a href=&quot;#目录-Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot; 目录 (Table of Contents)&quot;&gt;&lt;/a&gt; &lt;strong&gt;目录 (Table of C
      
    
    </summary>
    
      <category term="数据库" scheme="https://jasonsonghoho.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="cassandra" scheme="https://jasonsonghoho.github.io/public/tags/cassandra/"/>
    
      <category term="kairosdb" scheme="https://jasonsonghoho.github.io/public/tags/kairosdb/"/>
    
      <category term="TScached" scheme="https://jasonsonghoho.github.io/public/tags/TScached/"/>
    
      <category term="linux" scheme="https://jasonsonghoho.github.io/public/tags/linux/"/>
    
  </entry>
  
</feed>
