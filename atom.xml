<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jason&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasonsonghoho.github.io/"/>
  <updated>2020-07-21T14:14:24.871Z</updated>
  <id>https://jasonsonghoho.github.io/</id>
  
  <author>
    <name>jason song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flink 架构核心概念</title>
    <link href="https://jasonsonghoho.github.io/2020/04/11/Flink-%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>https://jasonsonghoho.github.io/2020/04/11/Flink-架构核心概念/</id>
    <published>2020-04-11T13:51:07.000Z</published>
    <updated>2020-07-21T14:14:24.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务和算子链"><a href="#任务和算子链" class="headerlink" title="任务和算子链"></a>任务和算子链</h3><p>先介绍一下：算子(Operator)</p><p>Logical Graph 是一种描述流处理程序的高阶逻辑有向图。边代表输入/输出关系、数据流和数据集之一。算子是 Logical Graph 的节点，执行某种操作，该操作通常由 Function 执行。Source 和 Sink 是数据输入和数据输出的特殊算子。</p><p>分布式计算中，Flink 将算子（operator）子任务（subtask） 链接成一个个的任务（task）。每个任务占一个单独的线程。把多个算子链接成一个任务减少了线程间切换和缓冲的开销，并且在降低延迟的同时提高了整体吞吐量。</p><p>下图的示例数据流由五个子任务执行，因此由五个并行线程执行。</p><img src="/2020/04/11/Flink-架构核心概念/operator.jpg" class="operator"><h4 id="Job-Managers、Task-Managers-和-Clients"><a href="#Job-Managers、Task-Managers-和-Clients" class="headerlink" title="Job Managers、Task Managers 和 Clients"></a>Job Managers、Task Managers 和 Clients</h4><p>Flink 运行环境包含两类进程：<br>JobManagers（“主管” master）主要用来协调分布式计算。它们负责调度任务、协调检查点（checkpoints，参见下面）、协调故障恢复等。至少得有一个 JobManager（必须得有个安排任务的），高可用环境下可以有多个 JobManagers，其中一个正常工作，其它的作为“备胎”。<br>TaskManagers（“搬砖工” woker）主要用来执行任务（确切来说是子任务），缓存产生的数据并交换数据流。TaskManager 也至少得有一个（也不能没有打工的…）。</p><p>JobManagers 和 TaskManagers 有多种启动方式：<br>直接在机器上启动称为 standalone 集群；<br>在容器或资源管理框架 中启动，如 YARN 或 Mesos，TaskManagers 会连接到 JobManagers，通知后者已经可用，然后开始工作。</p><p>客户端（Client）虽然不是运行时（runtime）和程序执行时的一部分，但它被用来准备数据流并向  JobManager  提交。提交完之后客户端就可以断开连接，或者保持连接来接收进度报告。客户端既可以作为 Java / Scala 程序启动，也可以在命令行中运行，如 ./bin/flink run …。</p><img src="/2020/04/11/Flink-架构核心概念/runtime.jpg" class="runtime"><h4 id="Task-Slots-和资源"><a href="#Task-Slots-和资源" class="headerlink" title="Task Slots 和资源"></a>Task Slots 和资源</h4><p>每个 worker（TaskManager）都是一个 JVM 进程，子任务通过其中不同的线程执行。每个 worker 可以接收任务的数量与它拥有的 task slots （可译为任务槽，至少一个）有关。</p><p>每个 task slot 可以认为是 TaskManager 的一份内存资源。例如，具有三个 slot 的 TaskManager 会将其管理的内存资源分成三等份，每个一份。划分资源可以避免子任务之间竞争资源，当然这也意味着它们拥有的资源大小是不可变的。不过 CPU 并没有隔离，只是平分了 woker 的内存资源。</p><p>用户可以通过调整 slot 的数量，调整子任务的隔离方式。若每个 TaskManager 只有一个 slot ，意味着每组任务占一个单独的 JVM 进程（例如，在一个单独的容器中启动）。如果一个 worker 有多个 slot ，则意味着多个子任务共享同一个 JVM。同一个 JVM 中的任务会共享 TCP 连接（通过多路复用技术）和心跳信息，还可以共享数据集和数据结构，从而降低整体开销。</p><img src="/2020/04/11/Flink-架构核心概念/taskSlots.jpg" class="taskSlots"><p>默认情况下，Flink 允许来自同一个 job 的子任务共享 slot，即使它们是不同 task 的子任务。因此，一个 slot 可能会负责这个 job 的一整条路径（结合图1理解）。允许 slot 共享有两个好处：</p><p>Flink 集群需要的 slot 与 job 中使用的最高并行度恰好一样多。这样不需要计算程序总共包含多少个任务（任务可能具有多种并行度）。</p><p>资源利用率更高。slot 不共享时，简单的子任务（如：source/map()）将会占用和复杂的子任务（如：window）一样多的资源。通过共享 slot，将示例中的并行度从 2 增加到 6 可以充分利用 slot 的资源，还可以确保繁重的子任务能在多个 TaskManagers 之间平均分配。</p><img src="/2020/04/11/Flink-架构核心概念/slots2.jpg" class="slots"><p>APIs 中包含了 resource group 机制，可以用来避免不必要的 slot 共享。</p><p>根据经验，slot 数量最好与 CPU 核数一致。使用超线程（hyper-threading）时，每个 slot 可以占用 2 个或更多的硬件线程。</p><h4 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h4><p>Flink 中的每个方法或算子都可以是有状态的。有状态的方法会在处理每个元素/事件的时候记录状态，从而使各种算子更加准确（因为可恢复）。Flink 使用 checkpoint（检查点）机制来保存状态。Checkpoint 能够恢复状态以及在数据流中的位置，从而保证无故障执行。</p><h4 id="State-Backends"><a href="#State-Backends" class="headerlink" title="State Backends"></a>State Backends</h4><p>不同类型的 state backend 会影响 key/values 索引存储时的数据结构。一种是将数据存储在基于内存的 HashMap 中，另一种会使用 RocksDB 存储。state backend 定义了数据结构的保存状态（state），定义了如何创建 key/values 的快照，并将该快照存储为 checkpoint 的一部分。</p><img src="/2020/04/11/Flink-架构核心概念/stateBackend.jpg" class="stateBackend"><h4 id="Savepoints"><a href="#Savepoints" class="headerlink" title="Savepoints"></a>Savepoints</h4><p>用 Data Stream API 编写的程序可以从 savepoint 恢复执行。Savepoints 可以保证在更新、升级代码和 Flink 集群配置时，不丢失任何状态。</p><p>Savepoints 可以理解为手动触发的 checkpoints，类似常规的 checkpoint 机制，它会对程序创建一个快照并将其保存到 state backend。程序会定期在 worker 上创建快照并生成 checkpoints。Flink 只需要最后一个完整的 checkpoint 来确保恢复，一旦创建好了新的 checkpoint，旧的就可以丢弃。</p><p>Savepoints 类似于 checkpoints，只不过是手动触发的，并且在新的 checkpoint 创建好后不会自动过期。你可以通过命令行来创建 Savepoints，或者在取消一个 job 时通过 REST API 来创建。</p><p><em>翻译自<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/concepts/runtime.html" target="_blank" rel="noopener">官方文档</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务和算子链&quot;&gt;&lt;a href=&quot;#任务和算子链&quot; class=&quot;headerlink&quot; title=&quot;任务和算子链&quot;&gt;&lt;/a&gt;任务和算子链&lt;/h3&gt;&lt;p&gt;先介绍一下：算子(Operator)&lt;/p&gt;
&lt;p&gt;Logical Graph 是一种描述流处理程序的高阶逻
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://jasonsonghoho.github.io/public/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="中间件" scheme="https://jasonsonghoho.github.io/public/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>5分钟了解算法开发的主要流程</title>
    <link href="https://jasonsonghoho.github.io/2020/04/01/5%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://jasonsonghoho.github.io/2020/04/01/5分钟了解算法开发的主要流程/</id>
    <published>2020-04-01T09:56:55.000Z</published>
    <updated>2020-04-01T10:05:37.519Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：5分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本文主要针对算法小白，用于了解算法开发的主要流程和术语。不当之处，还望包含。</p><h4 id="主要流程如下："><a href="#主要流程如下：" class="headerlink" title="主要流程如下："></a>主要流程如下：</h4><ol><li>问题抽象：确定问题类型。<br>分类、回归、标注等</li><li>数据收集处理（特征工程）<br>训练集、验证集、测试集</li><li>确定假设空间：找到合适的算法去进行预测</li><li>模型最优化：确定一个假设函数来确定假设空间的最优解</li><li>模型评估：判定模型的效果怎么样。<br>若效果不好，则 1.换参数  2.换算法 3.特征工程进一步处理</li><li>模型预测：模型上线使用<br>模型以API形式提供</li></ol><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="机器学习类型"><a href="#机器学习类型" class="headerlink" title="机器学习类型"></a>机器学习类型</h4><h5 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h5><p>根据训练数据是否拥有标记信息，学习任务可分为监督学习（如分类、回归、标注）和无监督学习（如聚类）。</p><h5 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h5><p>若我们欲预测的是离散值，如：好瓜、坏瓜。此类学习任务称为分类。</p><h5 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h5><p>若欲预测的是连续值，如西瓜成熟度：0.91、0.65。此类学习任务称为回归。</p><h5 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h5><p>可以认为标注问题是分类问题的一个推广。</p><p>标注问题的输入是一个观测序列，输出的是一个标记序列或状态序列。也就是说，分类问题的输出是一个值，而标注问题输出是一个向量，向量的每个值属于一种标记类型。</p><h5 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a>聚类问题</h5><p>通常，人们根据样本间的某种距离或者相似性来定义聚类，即把相似的（或距离近的）样本聚为同一类，而把不相似的（或距离远的）样本归在其他类。</p><p>聚类的目标：组内的对象相互之间是相似的（相关的），而不同组中的对象是不同的（不相关的）。组内的相似性越大，组间差别越大，聚类就越好。</p><h4 id="数据集类型"><a href="#数据集类型" class="headerlink" title="数据集类型"></a>数据集类型</h4><h5 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h5><p>作用：估计模型<br>学习样本数据集，通过匹配一些参数来建立一个分类器。建立一种分类的方式，主要是用来训练模型的。</p><h5 id="验证集"><a href="#验证集" class="headerlink" title="验证集"></a>验证集</h5><p>作用：确定网络结构或者控制模型复杂程度的参数<br>对学习出来的模型，调整分类器的参数，如在神经网络中选择隐藏单元数。验证集还用来确定网络结构或者控制模型复杂程度的参数。</p><h5 id="测试集"><a href="#测试集" class="headerlink" title="测试集"></a>测试集</h5><p>作用：检验最终选择最优的模型的性能如何<br>主要是测试训练好的模型的分辨能力（识别率等）</p><h4 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h4><h5 id="假设空间与模型的关系"><a href="#假设空间与模型的关系" class="headerlink" title="假设空间与模型的关系"></a>假设空间与模型的关系</h5><p>监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。换句话说，学习的目的就在于找到最好的这样的模型。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。假设空间的确定意味着学习范围的确定。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>《机器学习》周志华</p><p>《统计学习方法》李航</p><img src="/2020/04/01/5分钟了解算法开发的主要流程/WechatIMG178.jpeg" title="东哥声情并茂的指导">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：5分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;本文主要针对算法小白，用于了解算法开发的主要流程和术语。不当之处，还望包含。&lt;/p&gt;

      
    
    </summary>
    
      <category term="算法" scheme="https://jasonsonghoho.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>WebSocket 快速上手</title>
    <link href="https://jasonsonghoho.github.io/2019/09/21/WebSocket-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://jasonsonghoho.github.io/2019/09/21/WebSocket-快速上手/</id>
    <published>2019-09-21T10:58:29.000Z</published>
    <updated>2019-09-21T12:29:24.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍如何基于 SpringBoot 快速搭建 WebSocket 服务端和客户端。</p><h3 id="WebSocket-使用场景"><a href="#WebSocket-使用场景" class="headerlink" title="WebSocket 使用场景"></a>WebSocket 使用场景</h3><p>与 Http 协议相比，WebSocket 有两大优势：</p><ol><li>支持服务端主动向客户端推送消息，不需要客户端进行轮询服务端。</li><li>节省网络带宽。维持一个长连接，客户端和服务端通信不需要频繁的建立连接。且互相沟通的Header非常小。</li></ol><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>开始搞起</p><h3 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--服务端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;!--版本自选--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--客户端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.0&lt;/version&gt; &lt;!--版本自选--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><p>新建一个 SpringBoot 应用。添加 MyWebSocket 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.websocket.*;</span><br><span class="line">import javax.websocket.server.PathParam;</span><br><span class="line">import javax.websocket.server.ServerEndpoint;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@ServerEndpoint(&quot;/myWebSocket/&#123;id&#125;&quot;)</span><br><span class="line">public class MyWebSocket &#123;</span><br><span class="line"></span><br><span class="line">    public static String heartBeat = &quot;HeartBeat&quot;;</span><br><span class="line">    public static ConcurrentHashMap&lt;Long, MyWebSocket&gt; webSocketMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 与某个客户端的连接会话，需要通过它来与客户端进行数据收发</span><br><span class="line">     */</span><br><span class="line">    private Session session;</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    public static int getOnlineCount() &#123;</span><br><span class="line">        return webSocketMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @OnOpen</span><br><span class="line">    public void onOpen(Session session, @PathParam(&quot;id&quot;) Long id) &#123;</span><br><span class="line">        log.info(&quot;Open a webSocket. id=&#123;&#125;&quot;, id);</span><br><span class="line">        this.session = session;</span><br><span class="line">        this.id = id;</span><br><span class="line">        webSocketMap.put(id, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnClose</span><br><span class="line">    public void onClose() &#123;</span><br><span class="line">        webSocketMap.remove(id);</span><br><span class="line">        log.info(&quot;Close a webSocket. id:&#123;&#125;&quot;, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnMessage</span><br><span class="line">    public void onMessage(String message, Session session) &#123;</span><br><span class="line">        if (heartBeat.equals(message)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">                log.debug(&quot;Receive a heartBeat message from client: &#123;&#125;. id:&#123;&#125;&quot;, message, id);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(&quot;回复心跳信息失败！&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;Receive a message from client: &#123;&#125;. id:&#123;&#125;&quot;, message, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnError</span><br><span class="line">    public void onError(Session session, Throwable error) &#123;</span><br><span class="line">        log.error(&quot;Error while webSocket. &quot;, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Session getSession() &#123;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.java_websocket.client.WebSocketClient;</span><br><span class="line">import org.java_websocket.drafts.Draft;</span><br><span class="line">import org.java_websocket.drafts.Draft_6455;</span><br><span class="line">import org.java_websocket.handshake.ServerHandshake;</span><br><span class="line"></span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.net.URISyntaxException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class TestWebSocketClient extends WebSocketClient &#123;</span><br><span class="line">    public static String heartBeat = &quot;HeartBeat&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public TestWebSocketClient(URI serverUri, Draft protocolDraft) &#123;</span><br><span class="line">        super(serverUri, protocolDraft);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws URISyntaxException, InterruptedException &#123;</span><br><span class="line">        //端口号与 SpringBoot 的 servlet 容器端口一致</span><br><span class="line">        String serverUrl = &quot;ws://localhost:9292/myWebSocket/2000000000462815&quot;;</span><br><span class="line">        URI recognizeUri = new URI(serverUrl);</span><br><span class="line">        TestWebSocketClient client = new TestWebSocketClient(recognizeUri, new Draft_6455());</span><br><span class="line">        client.connectBlocking(5, TimeUnit.SECONDS);</span><br><span class="line">        client.send(&quot;This is a message from client. &quot;);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            client.send(heartBeat);</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onOpen(ServerHandshake serverHandshake) &#123;</span><br><span class="line">        log.info(&quot;Open a WebSocket connection on client. &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClose(int code, String reason, boolean remote) &#123;</span><br><span class="line">        log.info(&quot;Close a WebSocket connection on client.  &#123;&#125; &#123;&#125; &#123;&#125;&quot;, code, reason, remote);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(String message) &#123;</span><br><span class="line">        log.info(&quot;WebSocketClient receives a message: &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Exception exception) &#123;</span><br><span class="line">        log.error(&quot;WebSocketClient exception. &quot;, exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebSocketConfig"><a href="#WebSocketConfig" class="headerlink" title="WebSocketConfig"></a>WebSocketConfig</h3><p>用 SpringBoot 运行应用时，需要再添加一个配置文件，将 ServerEndpointExporter 注入 Bean 容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用spring boot运行应用时，打开 @Configuration 注释；使用 war 部署在tomcat时，关闭注释</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class WebSocketConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class="line">        return new ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>搞定，好快～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文介绍如何基于 SpringBoot 快速搭建 WebSocket 服务端和客户端。&lt;/p&gt;
&lt;h3 id=&quot;WebSocket-使用场景
      
    
    </summary>
    
    
      <category term="WebSocket" scheme="https://jasonsonghoho.github.io/public/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>使用taro开发微信小程序——入门</title>
    <link href="https://jasonsonghoho.github.io/2019/08/13/%E4%BD%BF%E7%94%A8taro%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <id>https://jasonsonghoho.github.io/2019/08/13/使用taro开发微信小程序——入门/</id>
    <published>2019-08-13T10:30:32.000Z</published>
    <updated>2019-08-14T13:16:09.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="taro-是什么"><a href="#taro-是什么" class="headerlink" title="taro 是什么"></a>taro 是什么</h3><p>Taro 是一套遵循 React 语法规范的 多端开发 解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。</p><p>使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native 等）运行的代码。</p><h3 id="支持多端开发转化"><a href="#支持多端开发转化" class="headerlink" title="支持多端开发转化"></a>支持多端开发转化</h3><p>Taro 方案的初心就是为了打造一个多端开发的解决方案。目前 Taro 代码可以支持转换到 微信/百度/支付宝/字节跳动/QQ小程序 、快应用、 H5 端 以及 移动端（React Native）。</p><img src="/2019/08/13/使用taro开发微信小程序——入门/platforms.jpg"><h2 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h2><h3 id="安装-taro-cli"><a href="#安装-taro-cli" class="headerlink" title="安装 taro cli"></a>安装 taro cli</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用 npm 安装 CLI</span><br><span class="line">$ npm install -g @tarojs/cli</span><br><span class="line"># OR 使用 yarn 安装 CLI</span><br><span class="line">$ yarn global add @tarojs/cli</span><br><span class="line"># OR 安装了 cnpm，使用 cnpm 安装 CLI</span><br><span class="line">$ cnpm install -g @tarojs/cli</span><br></pre></td></tr></table></figure><h3 id="demo-工程"><a href="#demo-工程" class="headerlink" title="demo 工程"></a>demo 工程</h3><p>可以网上下载一个 taro 的 demo 工程，我们以 <a href="https://github.com/imageslr/taro-library" target="_blank" rel="noopener">taro-library</a> 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/imageslr/taro-library.git</span><br><span class="line"></span><br><span class="line">$ cd taro-library</span><br><span class="line"></span><br><span class="line">$ npm install 或者 yarn</span><br><span class="line"></span><br><span class="line">$ npm run dev:weapp</span><br><span class="line"></span><br><span class="line">// 新建一个终端，在项目根目录下执行</span><br><span class="line">$ gulp mock</span><br></pre></td></tr></table></figure><p>需要注意的是，最好使工程的依赖与 cli 版本一致，否则运行时可能会出现一些奇怪的错误。</p><img src="/2019/08/13/使用taro开发微信小程序——入门/taro-version.jpg"><h3 id="导入-微信开发者工具"><a href="#导入-微信开发者工具" class="headerlink" title="导入 微信开发者工具"></a>导入 微信开发者工具</h3><p>执行完 <code>npm run dev:weapp</code> 之后，将会在项目的 dist 文件夹中生成相应的小程序工程。</p><p>安装好 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">微信开发者工具</a> 之后启动，选择导入项目。<strong>目录</strong>选择 taro-library 的 dist 文件夹，<strong>AppID</strong>选择测试号。</p><img src="/2019/08/13/使用taro开发微信小程序——入门/new-weapp.jpg"><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><img src="/2019/08/13/使用taro开发微信小程序——入门/debug-weapp.jpg"><h3 id="easy-mock"><a href="#easy-mock" class="headerlink" title="easy-mock"></a>easy-mock</h3><p>数据是在本机mock的，如果想要真机调试。可以使用我司的 <a href="https://easy-mock.com/" target="_blank" rel="noopener">easy-mock</a> 来 mock 在线数据，使用方便。</p><img src="/2019/08/13/使用taro开发微信小程序——入门/easy-mock.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;taro-是什么&quot;&gt;&lt;a href=&quot;#taro-是什么&quot; class=&quot;headerlink&quot; title=&quot;taro 是什么&quot;
      
    
    </summary>
    
    
      <category term="taro" scheme="https://jasonsonghoho.github.io/public/tags/taro/"/>
    
      <category term="微信小程序" scheme="https://jasonsonghoho.github.io/public/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java7 ConcurrentHashMap 简介</title>
    <link href="https://jasonsonghoho.github.io/2019/04/30/Java7-concurrentHashMap-%E7%AE%80%E4%BB%8B/"/>
    <id>https://jasonsonghoho.github.io/2019/04/30/Java7-concurrentHashMap-简介/</id>
    <published>2019-04-30T10:52:14.000Z</published>
    <updated>2019-04-30T15:37:18.334Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：15分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java7 ConcurrentHashMap 是线程安全的 HashMap。与 HashTable 的区别是，支持多个线程并发访问，吞吐量高。<br>结构如下：<br><img src="/2019/04/30/Java7-concurrentHashMap-简介/concurrentHashMap.png"></p><p>如图，ConcurrentHashMap 就是 Segment 数组，每个 Segment 可以理解为一个 HashMap。同一时间，每个 Segment 只允许一个线程访问。Segment 的数量在初始化后不再允许更改，但是每个 Segment 的长度是可以改变的。</p><h3 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h3><p>Unsafe 类是 jdk 提供的一个类，这个类提供了一些绕开 JVM 的更底层功能，基于它的实现可以提高效率。但它是一把双刃剑：正如它的名字所讲，它是 Unsafe 的，它所分配的内存需要手动 free（不被 GC 回收）。<br>ConcurrentHashMap 中反复用到了其中的几个方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * Sets the value of the object field at the specified offset in the</span><br><span class="line"> * supplied object to the given value.  This is an ordered or lazy</span><br><span class="line"> * version of &lt;code&gt;putObjectVolatile(Object,long,Object)&lt;/code&gt;, which</span><br><span class="line"> * doesn&apos;t guarantee the immediate visibility of the change to other</span><br><span class="line"> * threads.  It is only really useful where the object field is</span><br><span class="line"> * &lt;code&gt;volatile&lt;/code&gt;, and is thus expected to change unexpectedly.</span><br><span class="line"> * 设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者</span><br><span class="line"> * 有延迟的&lt;code&gt;putObjectVolatile&lt;/cdoe&gt;方法，并且不保证值的改变被其他线程立</span><br><span class="line"> * 即看到。只有在field被&lt;code&gt;volatile&lt;/code&gt;修饰并且期望被意外修改的时候</span><br><span class="line"> * 使用才有用。</span><br><span class="line"> *</span><br><span class="line"> * @param obj the object containing the field to modify.</span><br><span class="line"> *    包含需要修改field的对象</span><br><span class="line"> * @param offset the offset of the object field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line"> *       &lt;code&gt;obj&lt;/code&gt;中long型field的偏移量</span><br><span class="line"> * @param value the new value of the field.</span><br><span class="line"> *      field将被设置的新值</span><br><span class="line"> */</span><br><span class="line">public native void putOrderedObject(Object obj, long offset, Object value);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">  * Retrieves the value of the object field at the specified offset in the</span><br><span class="line">  * supplied object with volatile load semantics.</span><br><span class="line">  * 获取obj对象中offset偏移地址对应的object型field的值,支持volatile load语义。</span><br><span class="line">  *</span><br><span class="line">  * @param obj the object containing the field to read.</span><br><span class="line">  *    包含需要去读取的field的对象</span><br><span class="line">  * @param offset the offset of the object field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line">  *       &lt;code&gt;obj&lt;/code&gt;中object型field的偏移量</span><br><span class="line">  */</span><br><span class="line"> public native Object getObjectVolatile(Object obj, long offset);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * Compares the value of the object field at the specified offset</span><br><span class="line"> * in the supplied object with the given expected value, and updates</span><br><span class="line"> * it if they match.  The operation of this method should be atomic,</span><br><span class="line"> * thus providing an uninterruptible way of updating an object field.</span><br><span class="line"> * 在obj的offset位置比较object field和期望的值，如果相同则更新。这个方法</span><br><span class="line"> * 的操作应该是原子的，因此提供了一种不可中断的方式更新object field。</span><br><span class="line"> *</span><br><span class="line"> * @param obj the object containing the field to modify.</span><br><span class="line"> *    包含要修改field的对象</span><br><span class="line"> * @param offset the offset of the object field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line"> *         &lt;code&gt;obj&lt;/code&gt;中object型field的偏移量</span><br><span class="line"> * @param expect the expected value of the field.</span><br><span class="line"> *               希望field中存在的值</span><br><span class="line"> * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;.</span><br><span class="line"> *               如果期望值expect与field的当前值相同，设置filed的值为这个新值</span><br><span class="line"> * @return true if the field was changed.</span><br><span class="line"> *              如果field的值被更改</span><br><span class="line"> */</span><br><span class="line">public native boolean compareAndSwapObject(Object obj, long offset, Object expect, Object update);</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>见注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    int sshift = 0;</span><br><span class="line">    //ssize 是不小于预设并发度且为2的幂数的最小值</span><br><span class="line">    int ssize = 1;</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //segmentShift 和 segmentMask 是用于计算 Segment 位置的,int j =(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask 。</span><br><span class="line">    this.segmentShift = 32 - sshift;</span><br><span class="line">    this.segmentMask = ssize - 1;</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    // c 是每个 Segment 的容量</span><br><span class="line">    int c = initialCapacity / ssize;</span><br><span class="line">    if (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    int cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    while (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= 1;</span><br><span class="line">    // 创建 Segment 数组，并初始化 Segment[0]。</span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]</span><br><span class="line">    this.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    int h = hash(key);</span><br><span class="line">    //u 是该 Segment 在数组中的位置</span><br><span class="line">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    //Segment 不为空且 Segment 的 HashEntry 数组不为空时，遍历链表找到值返回；否则返回 null 。</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br><span class="line">        (tab = s.table) != null) &#123;</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != null; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put 较复杂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    //如果要插入的 Segment 为 null，执行 ensureSegment ,初始化它。</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == null)</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    //调用 Segment 的 put 方法</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ensureSegment 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] ss = this.segments;</span><br><span class="line">    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">        //使用 Segment[0] 的容量和负载因子初始化该 Segment</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[0];</span><br><span class="line">        int cap = proto.table.length;</span><br><span class="line">        float lf = proto.loadFactor;</span><br><span class="line">        int threshold = (int)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">        //使用 CAS 将该 Segment 初始化</span><br><span class="line">        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123; // recheck</span><br><span class="line">            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际执行插入的 Segment 的 put 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //尝试获取一次锁，获取到往下走；否则执行 scanAndLockForPut 方法来获取锁</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        int index = (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        //获取到头节点，如果链表为空，插入该值直接返回 null；</span><br><span class="line">        //否则进行遍历，找到相应 key 则进行修改,返回旧值，没找到则在最后插入该值然后返回 null。</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node != null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c = count + 1;</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于获取锁的 scanAndLockForPut：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = null;</span><br><span class="line">    int retries = -1; // negative while locating node</span><br><span class="line">    //循环调用 tryLock() 尝试获取锁（自旋），当对某一元素的自旋次数超过一定次数时将被阻塞</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; // to recheck first below</span><br><span class="line">        //自旋开始时，先遍历找到对应的元素</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null) &#123;</span><br><span class="line">                if (node == null) // speculatively create node</span><br><span class="line">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                retries = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //MAX_SCAN_RETRIES:最大加锁尝试次数，单核下为1；多核下为64。</span><br><span class="line">        //如果已经超过最大尝试次数则停止自旋，当前线程被阻塞，休眠一直到该锁可以获取。</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果 retries 为偶数且该表头元素已经更改则重新开始自旋</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f; // re-traverse if entry changed</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>实际执行扩容的是 Segment 的 rehash 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    //容量翻倍</span><br><span class="line">    int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">    int sizeMask = newCapacity - 1;</span><br><span class="line">    for (int i = 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            int idx = e.hash &amp; sizeMask;</span><br><span class="line">            if (next == null)   //  Single node on list</span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            else &#123; // Reuse consecutive sequence at same slot</span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                int lastIdx = idx;</span><br><span class="line">                //第一次遍历，找出最后面有哪些连续的元素扩容后会在相同的节点上</span><br><span class="line">                //根据概率来讲，平均后面 5/6 的数据都会在相同的节点上</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != null;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    int k = last.hash &amp; sizeMask;</span><br><span class="line">                    if (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                // 克隆分界节点（lastrun）之前的所有元素</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    int h = p.hash;</span><br><span class="line">                    int k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int nodeIndex = node.hash &amp; sizeMask; // add the new node</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isEmpty-、size"><a href="#isEmpty-、size" class="headerlink" title="isEmpty()、size()"></a>isEmpty()、size()</h3><p>isEmpty 与 size 两个方法与 HashMap 有些区别。因为它要遍历的对象是所有 Segment。直接对所有 Segment 加锁遍历十分影响性能，因此这两个方法用了共同的特殊技巧来实现。</p><p>isEmpty 方法会不加锁遍历两次，只要两次获取到的 modCount(修改次数)不一致或某个 Segment 的元素不为0，则认为不为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    long sum = 0L;</span><br><span class="line">    final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">    for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        if (seg != null) &#123;</span><br><span class="line">            if (seg.count != 0)</span><br><span class="line">                return false;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum != 0L) &#123; // recheck unless no modifications</span><br><span class="line">        for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            if (seg != null) &#123;</span><br><span class="line">                if (seg.count != 0)</span><br><span class="line">                    return false;</span><br><span class="line">                sum -= seg.modCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum != 0L)</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>size 方法也会先执行两次不加锁的遍历，若两次获取的 size 的大小一致则直接返回，否则加锁重新获取 size。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    // Try a few times to get accurate count. On failure due to</span><br><span class="line">    // continuous async changes in table, resort to locking.</span><br><span class="line">    final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">    int size;</span><br><span class="line">    boolean overflow; // true if size overflows 32 bits</span><br><span class="line">    long sum;         // sum of modCounts</span><br><span class="line">    long last = 0L;   // previous sum</span><br><span class="line">    int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //前两次遍历获取的 size 的大小不一致，则加锁获取 size。</span><br><span class="line">            if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); // force creation</span><br><span class="line">            &#125;</span><br><span class="line">            sum = 0L;</span><br><span class="line">            size = 0;</span><br><span class="line">            overflow = false;</span><br><span class="line">            for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                if (seg != null) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    int c = seg.count;</span><br><span class="line">                    if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">                        overflow = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sum == last)</span><br><span class="line">                break;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //如果加锁了，需要进行解锁</span><br><span class="line">        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果 size 已超过32位，则取 Integer.MAX_VALUE，否则取实际的 size。</span><br><span class="line">    return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>个人陋见难免疏漏，不足之处还请多多指教。😄</p><p>江湖路远，我们下期再会。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：15分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Java7 ConcurrentHashMap 是线程安全的 HashMap。与 H
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="ConcurrentHashMap" scheme="https://jasonsonghoho.github.io/public/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel 使用简介</title>
    <link href="https://jasonsonghoho.github.io/2019/03/18/Sentinel%E7%AE%80%E4%BB%8B/"/>
    <id>https://jasonsonghoho.github.io/2019/03/18/Sentinel简介/</id>
    <published>2019-03-18T08:04:27.000Z</published>
    <updated>2019-03-18T10:43:29.225Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/18/Sentinel简介/sentinel-logo.png"><h3 id="Sentinel-是什么"><a href="#Sentinel-是什么" class="headerlink" title="Sentinel 是什么"></a>Sentinel 是什么</h3><p>Sentinel 是面向分布式服务架构的轻量级 <strong>流量控制框架</strong>，可以从 <strong>流量控制、熔断降级、系统负载保护</strong> 等多个维度来保护服务的稳定性。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>可以理解为限制某种请求的最大 QPS 或它能同时发起的最大线程数。控制行为可以是 <strong>直接拒绝、排队等候、缓慢启动</strong> 等。</p><h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><p>当某种请求的连续的几次请求都超时或表现出其他异常，影响到服务的健康时，可以在接下来的一段时间内拒绝相同的请求，以保护服务健康。</p><h4 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h4><p>从整体维度对应用入口流量进行控制，结合应用的 Load、总体平均 RT(RequestTime)、入口 QPS 和线程数等几个维度的监控指标，<strong>让系统的入口流量和系统的负载达到一个平衡</strong>，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><img src="/2019/03/18/Sentinel简介/sentinel功能.png"><h3 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h3><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>资源是 Sentinel 的关键概念。 <strong>它可以是 Java 应用程序中的任何内容</strong>，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以 <strong>动态实时调整</strong> 。</p><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><h4 id="1-添加-POM-依赖"><a href="#1-添加-POM-依赖" class="headerlink" title="1.添加 POM 依赖"></a>1.添加 POM 依赖</h4><p>Sentinel 的使用可以分为两个部分:</p><ul><li>核心库（Java 客户端）：核心功能实现包。不依赖任何框架/库，能够运行于 Java 7 及以上的版本的运行时环境。</li><li>控制台（Dashboard）：Dashboard主要负责管理推送规则；监控；管理机器信息等。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 核心库 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 与控制台交互用 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-定义资源"><a href="#2-定义资源" class="headerlink" title="2.定义资源"></a>2.定义资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    initFlowRules();</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        Entry entry = null;</span><br><span class="line">        try &#123;</span><br><span class="line">    entry = SphU.entry(&quot;HelloWorld&quot;);</span><br><span class="line">            /*您的业务逻辑 - 开始*/</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">            /*您的业务逻辑 - 结束*/</span><br><span class="line">&#125; catch (BlockException e1) &#123;</span><br><span class="line">            /*流控逻辑处理 - 开始*/</span><br><span class="line">    System.out.println(&quot;block!&quot;);</span><br><span class="line">            /*流控逻辑处理 - 结束*/</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   if (entry != null) &#123;</span><br><span class="line">       entry.exit();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-定义规则"><a href="#3-定义规则" class="headerlink" title="3.定义规则"></a>3.定义规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static void initFlowRules()&#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    FlowRule rule = new FlowRule();</span><br><span class="line">    rule.setResource(&quot;HelloWorld&quot;);</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    // Set limit QPS to 20.</span><br><span class="line">    rule.setCount(20);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动该 demo 工程，参数添加 <code>-Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=data-gateway</code></p><h4 id="4-启动控制台观察结果"><a href="#4-启动控制台观察结果" class="headerlink" title="4.启动控制台观察结果"></a>4.启动控制台观察结果</h4><p>下载 <a href="git@github.com:alibaba/Sentinel.git">alibaba/Sentinel</a> 工程，本地启动 sentinel-dashboard 模块，运行参数添加 <code>-Dserver.port=8080</code> 。</p><img src="/2019/03/18/Sentinel简介/sentinel控制台.png" title="sentinel控制台"><p>更多 demo 可参考 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-demo" target="_blank" rel="noopener">Sentinel Examples</a></p><h3 id="规则详情"><a href="#规则详情" class="headerlink" title="规则详情"></a>规则详情</h3><h4 id="流量控制规则-FlowRule"><a href="#流量控制规则-FlowRule" class="headerlink" title="流量控制规则 (FlowRule)"></a>流量控制规则 (FlowRule)</h4><h5 id="重要属性："><a href="#重要属性：" class="headerlink" title="重要属性："></a>重要属性：</h5><table><thead><tr><th>Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>resource</td><td>资源名，资源名是限流规则的作用对象</td><td></td></tr><tr><td>count</td><td>限流阈值</td><td>QPS 模式</td></tr><tr><td>grade</td><td>限流阈值类型，QPS 或线程数模式</td><td></td></tr><tr><td>limitApp</td><td>流控针对的调用来源</td><td>default，代表不区分调用来源</td></tr><tr><td>strategy</td><td>判断的根据是资源自身，还是根据其它关联资源 (refResource)，还是根据链路入口</td><td>根据资源本身</td></tr><tr><td>controlBehavior</td><td>流控效果（直接拒绝 / 排队等待 / 慢启动模式）</td><td>直接拒绝</td></tr></tbody></table><h5 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initFlowQpsRule() &#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    FlowRule rule = new FlowRule(resourceName);</span><br><span class="line">    // set limit qps to 20</span><br><span class="line">    rule.setCount(20);</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule.setLimitApp(&quot;default&quot;);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多内容可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">流量控制</a></p><h4 id="熔断降级规则-DegradeRule"><a href="#熔断降级规则-DegradeRule" class="headerlink" title="熔断降级规则 (DegradeRule)"></a>熔断降级规则 (DegradeRule)</h4><h5 id="重要属性：-1"><a href="#重要属性：-1" class="headerlink" title="重要属性："></a>重要属性：</h5><table><thead><tr><th>Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>resource</td><td>资源名，资源名是限流规则的作用对象</td><td></td></tr><tr><td>count</td><td>阈值,单位为 ms</td><td></td></tr><tr><td>timeWindow</td><td>降级的时间，单位为 s</td><td></td></tr><tr><td>grade</td><td>降级模式，根据 RT 降级还是根据异常比例降级</td><td>RT</td></tr></tbody></table><h5 id="demo-1"><a href="#demo-1" class="headerlink" title="demo:"></a>demo:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void initDegradeRule() &#123;</span><br><span class="line">    List&lt;DegradeRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    DegradeRule rule = new DegradeRule();</span><br><span class="line">    rule.setResource(KEY);</span><br><span class="line">    rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);</span><br><span class="line">    // 若连续 5 个请求的响应时间均超过 300 ms ，将会被熔断 10S</span><br><span class="line">    rule.setCount(300);</span><br><span class="line">    rule.setTimeWindow(10);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    DegradeRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多内容可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7" target="_blank" rel="noopener">熔断降级</a></p><h4 id="系统保护规则-SystemRule"><a href="#系统保护规则-SystemRule" class="headerlink" title="系统保护规则 (SystemRule)"></a>系统保护规则 (SystemRule)</h4><h5 id="重要属性：-2"><a href="#重要属性：-2" class="headerlink" title="重要属性："></a>重要属性：</h5><table><thead><tr><th>Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>highestSystemLoad</td><td>最大的 load1，参考值</td><td>-1 (不生效)</td></tr><tr><td>avgRt</td><td>所有入口流量的平均响应时间</td><td>-1 (不生效)</td></tr><tr><td>maxThread</td><td>入口流量的最大并发数</td><td>-1 (不生效)</td></tr><tr><td>qps</td><td>所有入口资源的 QPS</td><td>-1 (不生效)</td></tr></tbody></table><h5 id="demo-2"><a href="#demo-2" class="headerlink" title="demo:"></a>demo:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void initSystemRule() &#123;</span><br><span class="line">    List&lt;SystemRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    SystemRule rule = new SystemRule();</span><br><span class="line">    rule.setHighestSystemLoad(10);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    SystemRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多内容可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81" target="_blank" rel="noopener">系统自适应限流</a></p><h4 id="授权规则-AuthorityRule"><a href="#授权规则-AuthorityRule" class="headerlink" title="授权规则 (AuthorityRule)"></a>授权规则 (AuthorityRule)</h4><h5 id="重要属性：-3"><a href="#重要属性：-3" class="headerlink" title="重要属性："></a>重要属性：</h5><table><thead><tr><th>Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>resource</td><td>资源名，资源名是限流规则的作用对象</td><td></td></tr><tr><td>limitApp</td><td>对应的黑名单/白名单，不同 origin 用 , 分隔，如 appA,appB</td><td></td></tr><tr><td>strategy</td><td>限制模式，AUTHORITY_WHITE 为白名单模式，AUTHORITY_BLACK 为黑名单模式</td><td>白名单</td></tr></tbody></table><h5 id="demo-3"><a href="#demo-3" class="headerlink" title="demo:"></a>demo:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AuthorityRule rule = new AuthorityRule();</span><br><span class="line">rule.setResource(&quot;test&quot;);</span><br><span class="line">rule.setStrategy(RuleConstant.AUTHORITY_WHITE);</span><br><span class="line">rule.setLimitApp(&quot;appA,appB&quot;);</span><br><span class="line">AuthorityRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure><p>更多内容可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">黑白名单控制</a></p><h4 id="热点规则-ParamFlowRule"><a href="#热点规则-ParamFlowRule" class="headerlink" title="热点规则 (ParamFlowRule)"></a>热点规则 (ParamFlowRule)</h4><h5 id="重要属性：-4"><a href="#重要属性：-4" class="headerlink" title="重要属性："></a>重要属性：</h5><table><thead><tr><th>Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>resource</td><td>资源名，必填</td><td></td></tr><tr><td>count</td><td>限流阈值，必填</td><td></td></tr><tr><td>paramIdx</td><td>热点参数的索引，必填，对应 SphU.entry(xxx, args) 中的参数索引位置</td><td></td></tr><tr><td>paramFlowItemList</td><td>参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面 count 阈值的限制。仅支持基本类型</td><td></td></tr><tr><td>grade</td><td>限流模式</td><td>QPS 模式</td></tr></tbody></table><h5 id="demo-4"><a href="#demo-4" class="headerlink" title="demo:"></a>demo:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ParamFlowRule rule = new ParamFlowRule(resourceName)</span><br><span class="line">    .setParamIdx(0)</span><br><span class="line">    .setCount(5);</span><br><span class="line">// 针对 int 类型的参数 PARAM_B，单独设置限流 QPS 阈值为 10，而不是全局的阈值 5.</span><br><span class="line">ParamFlowItem item = new ParamFlowItem().setObject(String.valueOf(PARAM_B))</span><br><span class="line">    .setClassType(int.class.getName())</span><br><span class="line">    .setCount(10);</span><br><span class="line">rule.setParamFlowItemList(Collections.singletonList(item));</span><br><span class="line"></span><br><span class="line">ParamFlowRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure><p>更多内容可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81" target="_blank" rel="noopener">热点参数限流</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/03/18/Sentinel简介/sentinel-logo.png&quot;&gt;
&lt;h3 id=&quot;Sentinel-是什么&quot;&gt;&lt;a href=&quot;#Sentinel-是什么&quot; class=&quot;headerlink&quot; title=&quot;Sentinel 是什么&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://jasonsonghoho.github.io/public/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>volatile、CAS、synchronized、ReentrantLock 简介</title>
    <link href="https://jasonsonghoho.github.io/2018/11/24/volatile%E3%80%81CAS%E3%80%81synchronized%E3%80%81ReentrantLock-%E7%AE%80%E4%BB%8B/"/>
    <id>https://jasonsonghoho.github.io/2018/11/24/volatile、CAS、synchronized、ReentrantLock-简介/</id>
    <published>2018-11-24T04:23:02.000Z</published>
    <updated>2018-11-24T14:59:54.059Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：10分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>volatile、CAS、synchronized、ReentrantLock 都是多线程中需要理解的重要知识，本文把它们放一起对比下，做个简单的介绍，为后面分析concurrent包源码打好基础。<br>其中 volatile 和 CAS 是用来保证对变量的操作的线程安全性，synchronized 和 Lock 是用来保证多个操作的线程安全性。</p><h3 id="一个实验"><a href="#一个实验" class="headerlink" title="一个实验"></a>一个实验</h3><p>我们先通过一个小实验来简单了解下他们的使用方法和区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicLab &#123;</span><br><span class="line">    private static final int LOOP_TIME = 500;</span><br><span class="line">    private static final Object LOCK = new Object();</span><br><span class="line">    private static Integer availableProcessors = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    private static Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static Integer i0 = 0;</span><br><span class="line">    private static volatile Integer i1 = 0;</span><br><span class="line">    private static Integer i2 = 0;</span><br><span class="line">    private static AtomicInteger i3 = new AtomicInteger();</span><br><span class="line">    private static Integer i4 = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;jasonLab-%d&quot;).build();</span><br><span class="line">        ExecutorService service = new ThreadPoolExecutor(availableProcessors + 1, availableProcessors * 2,</span><br><span class="line">                60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(5000), threadFactory);</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            service.execute(new TestThread0());</span><br><span class="line">            service.execute(new TestThread1());</span><br><span class="line">            service.execute(new TestThread2());</span><br><span class="line">            service.execute(new TestThread3());</span><br><span class="line">            service.execute(new TestThread4());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000L);</span><br><span class="line">        System.out.println(&quot;i0 result is &quot; + i0 + &quot; , equal 50000 : &quot; + (i0 == 50000));</span><br><span class="line">        System.out.println(&quot;i1 result is &quot; + i1 + &quot; , equal 50000 : &quot; + (i1 == 50000));</span><br><span class="line">        System.out.println(&quot;i2 result is &quot; + i2 + &quot; , equal 50000 : &quot; + (i2 == 50000));</span><br><span class="line">        System.out.println(&quot;i3 result is &quot; + i3 + &quot; , equal 50000 : &quot; + (i3.get() == 50000));</span><br><span class="line">        System.out.println(&quot;i4 result is &quot; + i4 + &quot; , equal 50000 : &quot; + (i4 == 50000));</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestThread0 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; LOOP_TIME; i++) &#123;</span><br><span class="line">                i0 += 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestThread1 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; LOOP_TIME; i++) &#123;</span><br><span class="line">                i1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestThread2 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; LOOP_TIME; i++) &#123;</span><br><span class="line">                synchronized (LOCK) &#123;</span><br><span class="line">                    i2 += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestThread3 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; LOOP_TIME; i++) &#123;</span><br><span class="line">                i3.getAndAdd(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestThread4 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; LOOP_TIME; i++) &#123;</span><br><span class="line">                    i4++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述 main 方法，一个可能的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i0 result is 48646 , equal 50000 : false</span><br><span class="line">i1 result is 48509 , equal 50000 : false</span><br><span class="line">i2 result is 50000 , equal 50000 : true</span><br><span class="line">i3 result is 50000 , equal 50000 : true</span><br><span class="line">i4 result is 50000 , equal 50000 : true</span><br></pre></td></tr></table></figure></p><p>上述实验是计算 100 个线程同时对同一个 i 进行<code>i++</code>操作的累加结果。<br>我们知道，<code>i++</code>操作其实分：读（getI()）、改（i=i+1）、写（setI(i)）三步进行的。<br>对于 i0，这三个操作都不具备原子性保证，所以多线程下难免会发生数据丢失的问题。而至于i1-i4，其实分别用到了标题中的四个知识点，我们依次介绍下它们。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>i1 被 volatile 修饰，它是 Java 中的关键字，它修饰的变量具有可见性和原子性的特点。</p><h4 id="可见性和原子性"><a href="#可见性和原子性" class="headerlink" title="可见性和原子性"></a>可见性和原子性</h4><p>可见性：如果一个变量具有可见性，可以理解为任意时刻得到的都是该变量的最新值。<br>原子性：指对该变量的操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。</p><h4 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h4><p>volatile 修饰的变量在进行操作时，会在汇编代码中加上 <code>Lock</code> 前缀，这将导致两件事情：</p><ol><li>所有处理器不会在本地内存中记录该变量，而是直接写到共享内存中。</li><li>所有处理器在读取该变量时，都直接从共享内存中读取。</li></ol><h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>根据实现原理，我们可以得知：<strong>对 volatile 变量的读或写都可以保证原子性</strong>。也就是上面的第一步和第三步是原子性的操作，但是第二步修改操作时却不能保证。<br>当一个线程执行修改操作时，其他线程可能已经执行过写入操作了，所以当该线程执行写入操作时，就覆盖了前面的写入操作，导致数据丢失。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>我们先看下 i3，可以看到它使用了原子更新整型：<code>AtomicInteger</code>，我们在进行累加时，使用了它的<code>getAndAdd()</code>方法。<br>这个方法其实最终调用了<code>Unsafe.compareAndSwapInt()</code>方法，这是个 native 方法，依赖 CAS（CompareAndSwap）原理实现。</p><h4 id="CAS-实现原理"><a href="#CAS-实现原理" class="headerlink" title="CAS 实现原理"></a>CAS 实现原理</h4><p>CAS 的实现使用了处理器提供的 <code>CMPXCHG</code>指令，这个指令也带有<code>Lock</code>前缀，在进行 CAS 操作时，会锁住相应的内存区域，其他不能操作相应内存区域的线程在外面循环进行尝试，实现多线程原子性。<br>进行 CAS 时，需要对三个值进行操作：现在的值、预期的值、要替换的值。只有当预期的值和当前值一致时，才会进行修改。</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS 操作可能会出现这样的问题：变量的值原来是A，被其他线程修改为了B，后来又被修改回A，当该线程进行CAS操作时，发现预期值与当前值一致，进行了修改。而其实变量已经被修改过了，这样就可能会导致其他的问题。JDK1.5开始，提供了<code>AtomicStampedReference</code>类来解决这个问题，变量会加一个类似乐观锁的版本号：1A-2B-3A。这样就可以准确的判断变量是否被修改过了。</p><h4 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h4><p>根据原理，我们可以得知针对 i3 的每次修改都是原子性的，没啥好说的～<br>synchronized 和 ReentrantLock 也不再进行结果分析。</p><h4 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h4><p>volatile 和 CAS 在 Java 中举足轻重。借一张图表示 Java concurrent 包的实现。</p><img src="/2018/11/24/volatile、CAS、synchronized、ReentrantLock-简介/concurrent包.png" title="concurrent 包实现"><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 是 Java 提供的一个关键字，用来锁住一个对象，被锁的对象任意时刻只能被一个线程访问（同一个线程可以加多个锁进行重复访问）。<br>synchronized 修饰不同的地方，加的锁的类型也不一样：</p><ol><li>修饰非静态方法，锁的是该方法所在的实例对象。</li><li>修饰静态方法，锁的是该类的类对象。</li><li>修饰代码块时，锁的是所指定的对象。</li></ol><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>任何一个对象都有一个 monitor 与之关联，当 monitor 被持有后，它就将处于锁定状态。synchronized 就是通过获取和释放 monitor 实现的。</p><img src="/2018/11/24/volatile、CAS、synchronized、ReentrantLock-简介/synchronized.png" title="synchronized（重量级锁）原理"><h4 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，Java6 开始，引入了<code>偏向锁</code>和<code>轻量级</code>锁的概念。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>获取到锁后，锁默认处于<code>偏向锁</code>状态，在锁对象的对象头中储存一个线程ID，当下次该线程尝试获取该锁时，不需要进行循环CAS取锁，只需要检测偏向锁的线程ID是否与之一致即可。<br>当多个线程对同一个锁竞争激烈时，偏向锁会升级为<code>轻量级锁</code>。</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>加锁：<br>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。<br>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>解锁：<br>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><p>轻量级锁能提高程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，<br>但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 实现了 Lock 接口，也是 JDK 中该接口的唯一实现。Lock 接口是在Java5新增的，提供了与 synchronized 相似的功能。</p><h4 id="与-synchronized-的区别"><a href="#与-synchronized-的区别" class="headerlink" title="与 synchronized 的区别"></a>与 synchronized 的区别</h4><ol><li><code>ReentrantLock</code>可以显示的进行加锁和解锁。</li><li><code>ReentrantLock</code>可中断的获取锁。</li><li><code>ReentrantLock</code>可以提供公平锁。</li><li><code>ReentrantLock</code>可以提供超时等待机制。</li></ol><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>ReentrantLock 的实现依赖于 AbstractQueueSynchronizer(AQS),它是实现锁或其他同步组件的基础框架。<br>AQS 内部维护了一个同步状态变量和一个同步队列，获取到该同步状态的线程视为获取到锁；获取失败的线程连同它的等待状态信息会被构造成加入到同步队列中，并阻塞它。<br>当同步状态被释放时，同步队列中的首节点会被唤醒尝试去获取同步状态。</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>如果一段代码中大部分时间都在执行读操作，多个读操作同时进行不会影响线程安全性，这时前面提到的独占锁明显会影响多线程的读取性能。<br><code>ReentrantReadWriteLock</code>是一个读写锁，多个获取了读锁之间的线程可以同步执行；而写锁不可以和读/写锁同步执行。<br>读写锁锁降级：一个线程在获取了写锁后，有获取了读锁，在释放写锁后，就变成了只获取了读锁，即锁降级。</p><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>ReentrantLock 使用 Condition 的 <code>await()</code>、<code>signal()</code>、<code>signalAll()</code>方法分别代替 Object 的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 方法。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上是关于这四者的简单介绍，为了后面的系列内容做下铺垫，想要了解详情可以参考更多书籍、资料。</p><hr><img src="/2018/11/24/volatile、CAS、synchronized、ReentrantLock-简介/img-6806f.gif">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：10分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;volatile、CAS、synchronized、ReentrantLock 都是
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="多线程" scheme="https://jasonsonghoho.github.io/public/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="volatile" scheme="https://jasonsonghoho.github.io/public/tags/volatile/"/>
    
      <category term="CAS" scheme="https://jasonsonghoho.github.io/public/tags/CAS/"/>
    
      <category term="synchronized" scheme="https://jasonsonghoho.github.io/public/tags/synchronized/"/>
    
      <category term="ReentrantLock" scheme="https://jasonsonghoho.github.io/public/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>Java8 ArrayList 源码解读</title>
    <link href="https://jasonsonghoho.github.io/2018/11/12/Java-ArrayList-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://jasonsonghoho.github.io/2018/11/12/Java-ArrayList-源码解读/</id>
    <published>2018-11-12T13:07:33.000Z</published>
    <updated>2018-11-15T12:31:07.331Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：10分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ArrayList 是日常开发中很常见的集合类型，在 Java 集合中相对容易阅读。它是基于数组实现的一种列表，读取、修改的时间复杂度很小（O(1)）, 插入、remove 时时间复杂度为O(n)。ArrayList 可以存放 null 值，列表清空就是通过把所有的元素置为 null 实现的。</p><h3 id="Arrays-copyOf-和-System-arraycopy"><a href="#Arrays-copyOf-和-System-arraycopy" class="headerlink" title="Arrays.copyOf() 和 System.arraycopy()"></a>Arrays.copyOf() 和 System.arraycopy()</h3><p>首先我们先看下代码里反复出现的两个方法：Arrays.copyOf() 和 System.arraycopy()。其实 <code>public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</code> 是通过调用后者实现的，输入待拷贝的数组和要返回数组的长度，拷贝出一个新的数组。而<code>public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos,int length)</code>是真正执行拷贝的方法。它是个 native 方法，五个参数分别代表 待拷贝数组、待拷贝数组的起始位置、目标数组、目标数组的插入位置、拷贝的长度。每次拷贝都是全量拷贝，因此容量变化的操作较多时，会对它造成性能影响。</p><h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p>ArrayList 实现了 RandomAccess 接口表示支持快速随机访问，将使用 for 循环查找元素。如果没有实现该接口（如 LinkedList），在查找时，只能通过 迭代器 进行查找，查找速度要低于前者。</p><p>Java doc 中具体解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* &lt;pre&gt;</span><br><span class="line">*     for (int i=0, n=list.size(); i &amp;lt; n; i++)</span><br><span class="line">*         list.get(i);</span><br><span class="line">* &lt;/pre&gt;</span><br><span class="line">* runs faster than this loop:</span><br><span class="line">* &lt;pre&gt;</span><br><span class="line">*     for (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line">*         i.next();</span><br><span class="line">* &lt;/pre&gt;</span><br></pre></td></tr></table></figure></p><h3 id="⭐注释版源码⭐"><a href="#⭐注释版源码⭐" class="headerlink" title="⭐注释版源码⭐"></a>⭐注释版源码⭐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认的初始化容量：10</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Object[]，用来存储列表元素</span><br><span class="line">     */</span><br><span class="line">    transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">    /**</span><br><span class="line">     * 按默认容量创建的空列表共享的存储对象</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    /**</span><br><span class="line">     * 指定容量创建的空列表共享的存储对象</span><br><span class="line">     */</span><br><span class="line">    private static final Object[]</span><br><span class="line">            EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    /**</span><br><span class="line">     * 列表中元素数量</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，指定容量大小</span><br><span class="line">     */</span><br><span class="line">    public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            this.elementData = new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">            //如果指定容量为0，使用 EMPTY_ELEMENTDATA</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 无参构造函数</span><br><span class="line">     */</span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        //使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，入参为一个集合类型</span><br><span class="line">     */</span><br><span class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        //调用 Collection 的 toArray() 方法，转换为 Object[]</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        if ((size = elementData.length) != 0) &#123;</span><br><span class="line">            // c.toArray 方法可能会转换出错，导致生成 Object[] 失败</span><br><span class="line">            if (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // replace with empty array.</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按实际元素数量重新申请存储空间以减少内存使用</span><br><span class="line">     */</span><br><span class="line">    public void trimToSize() &#123;</span><br><span class="line">        //修改次数。记录该 ArrayList 对象修改次数，防止并发执行修改操作导致数据不一致。</span><br><span class="line">        modCount++;</span><br><span class="line">        if (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == 0)</span><br><span class="line">                    ? EMPTY_ELEMENTDATA</span><br><span class="line">                    : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 确保容量足够，如果容量不够就扩容</span><br><span class="line">     */</span><br><span class="line">    public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">        //如果是按默认容量创建的空 ArrayList,则当指定的容量超过10时，才会扩容</span><br><span class="line">        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">                // any size if not default element table</span><br><span class="line">                ? 0</span><br><span class="line">                // larger than default for default empty table. It&apos;s already supposed to be at default size.</span><br><span class="line">                : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算最小容量</span><br><span class="line">    private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        return minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算出需要扩容的最小容量然后确保增加到该容量</span><br><span class="line">    private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //确保增加到指定的容量</span><br><span class="line">    private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 元素最大数量。因为有的虚拟机预留了用于保存数组对象大小等信息的元数据，故减去了8位。</span><br><span class="line">     */</span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实际执行 扩容方法</span><br><span class="line">     */</span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        //扩容到原来的 1.5倍</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        //如果扩容后仍小于要最小容量则直接取最小容量作为新的容量</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        //如果扩容后大于最大允许的容量，则执行 hugeCapacity</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 求扩容容量，如果实际指定的最小容量超过 MAX_ARRAY_SIZE ，</span><br><span class="line">     * 则取 Integer.MAX_VALUE。否则取 MAX_ARRAY_SIZE。</span><br><span class="line">     */</span><br><span class="line">    private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                Integer.MAX_VALUE :</span><br><span class="line">                MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回实际元素个数</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否为空</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否包含一个元素</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 求指定元素首次出现的下标。-1 表示不存在</span><br><span class="line">     */</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        //单独考虑所查元素为 null 时的情况</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定元素最后一次出现的下标。靠从后面遍历来实现的。</span><br><span class="line">     */</span><br><span class="line">    public int lastIndexOf(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 浅拷贝，只拷贝一个新的数组，元素未拷贝。</span><br><span class="line">     */</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = 0;</span><br><span class="line">            return v;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">            throw new InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转换为 Object[]</span><br><span class="line">     */</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转换为指定类型数组。</span><br><span class="line">     * 注意：若指定数组类型不是列表元素的超类，则会报 ArrayStoreException 异常。</span><br><span class="line">     * 若指定数组为 null ,会报空指针异常。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        if (a.length &lt; size)</span><br><span class="line">            // Make a new array of a&apos;s runtime type, but my contents:</span><br><span class="line">            return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">        if (a.length &gt; size)</span><br><span class="line">            a[size] = null;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Positional Access Operations</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get</span><br><span class="line">     */</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        //检测下标是否越界</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set</span><br><span class="line">     */</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * add</span><br><span class="line">     */</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        //先判断容量是否足够</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据下标删除</span><br><span class="line">     */</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        //需要移动的元素数量</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        //将数组最后一个元素设为 null,通过GC机制自动去回收空间</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据元素删除</span><br><span class="line">     */</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 与 remove(int index) 方法基本一致，只是没有下标越界检查、不返回旧值。</span><br><span class="line">     * 提升删除性能，作为私有方法。</span><br><span class="line">     */</span><br><span class="line">    private void fastRemove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所有元素全部置为 null</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // clear to let GC do its work</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            elementData[i] = null;</span><br><span class="line"></span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 追加一个集合的元素</span><br><span class="line">     */</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line">        System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        return numNew != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入一个集合的元素</span><br><span class="line">     */</span><br><span class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        return numNew != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除指定下标范围的元素</span><br><span class="line">     */</span><br><span class="line">    protected void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                numMoved);</span><br><span class="line"></span><br><span class="line">        // clear to let GC do its work</span><br><span class="line">        int newSize = size - (toIndex-fromIndex);</span><br><span class="line">        for (int i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检测下标是否越界</span><br><span class="line">     */</span><br><span class="line">    private void rangeCheck(int index) &#123;</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * add 和 addAll 方法中 检测下标是否越界。</span><br><span class="line">     */</span><br><span class="line">    private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">        if (index &gt; size || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String outOfBoundsMsg(int index) &#123;</span><br><span class="line">        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除在集合中出现的元素</span><br><span class="line">     * 可能会报 ClassCastException 和 空指针异常</span><br><span class="line">     */</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        return batchRemove(c, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 保留在集合中存在的元素</span><br><span class="line">     * 可能会报 ClassCastException 和 空指针异常</span><br><span class="line">     */</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        return batchRemove(c, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">        final Object[] elementData = this.elementData;</span><br><span class="line">        int r = 0, w = 0;</span><br><span class="line">        boolean modified = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            //遍历列表，根据 complement，选择是否保留元素</span><br><span class="line">            for (; r &lt; size; r++)</span><br><span class="line">                if (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //如果遍历过程中报错了，将剩余未遍历的元素追加到不完整的新列表的后面</span><br><span class="line">            if (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                        elementData, w,</span><br><span class="line">                        size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果列表有被修改，则将无效存储位置置为 null</span><br><span class="line">            if (w != size) &#123;</span><br><span class="line">                // clear to let GC do its work</span><br><span class="line">                for (int i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = null;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回是否做了修改</span><br><span class="line">        return modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对象序列化函数</span><br><span class="line">     */</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">            throws java.io.IOException&#123;</span><br><span class="line">        // Write out element count, and any hidden stuff</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line">        //执行默认的序列化函数，将除 elementData[] 外的属性序列化</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        // Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">        // 写入 size</span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        // Write out all elements in the proper order.</span><br><span class="line">        // 将 elementData[] 中的元素序列化进去</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //序列化过程中对象被修改，则报 ConcurrentModificationException 异常</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 反序列化函数</span><br><span class="line">     */</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">            throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        // Read in size, and any hidden stuff</span><br><span class="line">        // 反序列化出除 elementData[] 外的属性</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        // Read in capacity</span><br><span class="line">        // 读出 size ,可忽略</span><br><span class="line">        s.readInt(); // ignored</span><br><span class="line"></span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            // be like clone(), allocate array based upon size not capacity</span><br><span class="line">            // 计算出实际容量</span><br><span class="line">            int capacity = calculateCapacity(elementData, size);</span><br><span class="line">            // 检查是否转换为数组类型，容量是否小于0。此处实际上不需要第一个参数。</span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            // Read in all elements in the proper order.</span><br><span class="line">            // 执行反序列化</span><br><span class="line">            for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个迭代器 ListIterator</span><br><span class="line">     */</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">        return new ListItr(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个迭代器 ListIterator，指定初始迭代位置</span><br><span class="line">     */</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span><br><span class="line">        return new ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个迭代器 Iterator</span><br><span class="line">     */</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取子list</span><br><span class="line">     */</span><br><span class="line">    public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        return new SubList(this, 0, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //子list范围检查</span><br><span class="line">    static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123;</span><br><span class="line">        if (fromIndex &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);</span><br><span class="line">        if (toIndex &gt; size)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);</span><br><span class="line">        if (fromIndex &gt; toIndex)</span><br><span class="line">            throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +</span><br><span class="line">                    &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Java8 新加，供函数式编程遍历</span><br><span class="line">    @Override</span><br><span class="line">    public void forEach(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        final int expectedModCount = modCount;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        final E[] elementData = (E[]) this.elementData;</span><br><span class="line">        final int size = this.size;</span><br><span class="line">        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            action.accept(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个 Spliterator 对象。</span><br><span class="line">     * Spliterator 是 Java8 新加的、可分割的迭代器(splitable iterator)，对于并行处理的能力大大增强。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">        return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Predicate 是Java8 新加的类，可以理解为一个用来断言的类。</span><br><span class="line">     * 该方法应该是为了函数式编程新加的。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        // figure out which elements are to be removed</span><br><span class="line">        // any exception thrown from the filter predicate at this stage</span><br><span class="line">        // will leave the collection unmodified</span><br><span class="line">        int removeCount = 0;</span><br><span class="line">        final BitSet removeSet = new BitSet(size);</span><br><span class="line">        final int expectedModCount = modCount;</span><br><span class="line">        final int size = this.size;</span><br><span class="line">        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            final E element = (E) elementData[i];</span><br><span class="line">            if (filter.test(element)) &#123;</span><br><span class="line">                removeSet.set(i);</span><br><span class="line">                removeCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // shift surviving elements left over the spaces left by removed elements</span><br><span class="line">        final boolean anyToRemove = removeCount &gt; 0;</span><br><span class="line">        if (anyToRemove) &#123;</span><br><span class="line">            final int newSize = size - removeCount;</span><br><span class="line">            for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">                i = removeSet.nextClearBit(i);</span><br><span class="line">                elementData[j] = elementData[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">                elementData[k] = null;  // Let gc do its work</span><br><span class="line">            &#125;</span><br><span class="line">            this.size = newSize;</span><br><span class="line">            if (modCount != expectedModCount) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            modCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return anyToRemove;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Java8 新加，可以按指定规则替换所有元素。</span><br><span class="line">     * UnaryOperator 实现了 Function 接口，可以接收一个入参，处理后返回。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        final int expectedModCount = modCount;</span><br><span class="line">        final int size = this.size;</span><br><span class="line">        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 排序，Comparator 指定排序规则</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        final int expectedModCount = modCount;</span><br><span class="line">        //调用 Arrays 的排序方法，瞄了一眼，很复杂的样子...</span><br><span class="line">        Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="writeObject-和-readObject"><a href="#writeObject-和-readObject" class="headerlink" title="writeObject 和 readObject"></a>writeObject 和 readObject</h3><p>ArrayList 实现了 Serializable 接口，所以对象会被序列化。而存放元素的 elementData 中可能会存在元素数量比数组容量小很多的情况，序列化时就会造成大量的空间浪费，因此通过实现 writeObject 和 readObject 方法，即可重新定义序列化与反序列化的规则。ArrayList 在 elementData 前加上了 transient 取消其默认序列化规则，其他属性则执行默认的规则。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>iterator()</code>方法会返回一个 Iterator 迭代器，遍历时较常见。<br>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * AbstractList.Itr 的优化版 迭代器</span><br><span class="line"> */</span><br><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    // 当前下标</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    // 上一个元素的下标，-1 表示还没有上一个元素</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        //</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //Java8 新加的 遍历方法，供函数式编程使用</span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        final int size = ArrayList.this.size;</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        while (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        // update once at end of iteration to reduce heap write traffic</span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - 1;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查是否被修改过</span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>listIterator(int index)</code>、<code>listIterator()</code>这两个方法返回的是 ListIterator 迭代器，与 Iterator 相比，它支持反向遍历和 add() 方法，比较容易理解，不再赘述。</p><p>此外，还有一个 <code>spliterator()</code>方法，它返回的是一个 Java8 新加的 Spliterator 迭代器。Spliterator 是一个可分割迭代器(splitable iterator)，为了并行遍历元素而设计。如果有机会我们再分析它。</p><h3 id="sublist"><a href="#sublist" class="headerlink" title="sublist"></a>sublist</h3><p>ArrayList 提供的<code>public List&lt;E&gt; subList(int fromIndex, int toIndex)</code>方法允许返回一个子list。<br>根据注释得知：</p><ol><li>该方法返回的是父list的一个视图，从fromIndex（包含），到toIndex（不包含）。fromIndex=toIndex 表示子list为空</li><li>父子list做的非结构性修改（non-structural changes）都会影响到彼此：所谓的“非结构性修改”，是指不涉及到list的大小改变的修改。相反，结构性修改，指改变了list大小的修改。</li><li>对于结构性修改，子list的所有操作都会反映到父list上。但父list的修改将会导致返回的子list失效。</li><li>tips：删除list中的某段数据的方法：<code>list.subList(from, to).clear();</code></li></ol><hr><p>觉得有点收获的同学可以在手机上点击这个<a href="https://m.luckincoffee.com/invited/register?activityNo=NR201801030001&amp;inviteCode=8lB4421fo_6iv_eidD4_Fg%3D%3D&amp;secondfrom=0&amp;title=%E4%BB%8A%E5%A4%A9%E6%98%9F%E6%9C%9F%E4%B8%89%EF%BC%8C%E8%AF%B7%E4%BD%A0%E5%96%9D%E6%9D%AF%E5%85%8D%E8%B4%B9%E5%A4%A7%E5%B8%88%E5%92%96%E5%95%A1%EF%BC%8C%E6%96%B9%E6%A1%88%E4%B8%80%E7%A8%BF%E8%BF%87&amp;timestamp=1542129222502&amp;from=singlemessage" target="_blank" rel="noopener">链接</a> 免费领取一杯咖啡（瑞幸咖啡券，使用后我也得一张😃）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：10分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;ArrayList 是日常开发中很常见的集合类型，在 Java 集合中相对容易阅读。
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="ArrayList" scheme="https://jasonsonghoho.github.io/public/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>BitMap、BitSet与Bloom Filter</title>
    <link href="https://jasonsonghoho.github.io/2018/10/08/BitMap%E3%80%81BitSet%E4%B8%8EBloom%20Filter/"/>
    <id>https://jasonsonghoho.github.io/2018/10/08/BitMap、BitSet与Bloom Filter/</id>
    <published>2018-10-08T02:36:11.000Z</published>
    <updated>2018-10-30T09:03:13.706Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：5分钟</em></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>先来看一个问题，假设现在有范围为 1-10 亿的 11 亿个 int 型整数，如何排除掉其中的重复数字？int 占 4 个字节，可以表示 -2,147,483,648 ~ +2,147,483,647 的数据。<br>所以一般的思路是会将这 11 亿个数作为 int 型数据存到一个 HashSet 集合中进行去重。但是，这样会存在一个问题。我们知道 1GB=1024KB=1024 <em> 1024Byte,那么 10亿 </em> 4Byte 将占用接近 4GB 的内存，这将是极大的性能浪费，很可能会影响程序的健康运行。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以考虑用”位映射（BitMap）”来解决这个问题。试想一下，如果我们有一个位数组（bit[n]），那么我们可以用 bit[i] 来表示 0-n 中对应的数字，每个元素有 1 和 0 两个取值，分别代表该数字存在与否。这样一来，我们记录一个数字只需要一个 bit，相对于之前的 int 类型(32 bit)，整整缩小了 32 倍的存储大小(4GB/32=125MB)!</p><p>扩展一下，当我们需要记录每个数字出现次数是否超过 2 次时，可以使用连续的两位来记录一个数字：一位用来记录是否出现，另一位用来记录是否超过 2 次。</p><p>不过，Java 中无法创建 bit 数组，我们可以使用 int 或 long 数组来实现这个目的。建立一个 int 数组 int[n]，int[0] 记录了 0-31，int[1] 记录了 32-63 …… 依此类推。</p><h3 id="Java-BitSet"><a href="#Java-BitSet" class="headerlink" title="Java BitSet"></a>Java BitSet</h3><p>Java 中有一个 BitSet 类，从命名就可以看出它是用来存储去重的位元素集合，它还支持 and、or 等位运算。用来解决文章开头的问题非常合适，方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitSetStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet(<span class="number">1000000000</span>);</span><br><span class="line">        <span class="comment">//随机生成 11 亿个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1100000000</span>; i++) &#123;</span><br><span class="line">            bitSet.set((<span class="keyword">int</span>) (Math.random() * <span class="number">1000000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(bitSet.size());</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 jconsole,可以看到存储了 bitset 对象的老年代所占用的内存稳定在 125MB 左右。</p><img src="/2018/10/08/BitMap、BitSet与Bloom%20Filter/bitset-mem.png"><p>关于 BitSet 的 and、andNot、or、xor 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BitSet bitSet = <span class="keyword">new</span> BitSet();</span><br><span class="line">    bitSet.set(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    BitSet bitSet1 = <span class="keyword">new</span> BitSet();</span><br><span class="line">    bitSet1.set(<span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    BitSet bitSetAnd = (BitSet) bitSet.clone();</span><br><span class="line">    BitSet bitSetAndNot = (BitSet) bitSet.clone();</span><br><span class="line">    BitSet bitSetOr = (BitSet) bitSet.clone();</span><br><span class="line">    BitSet bitSetXor = (BitSet) bitSet.clone();</span><br><span class="line"></span><br><span class="line">    bitSetAnd.and(bitSet1);</span><br><span class="line">    bitSetAndNot.andNot(bitSet1);</span><br><span class="line">    bitSetOr.or(bitSet1);</span><br><span class="line">    bitSetXor.xor(bitSet1);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"bitSet is : "</span> + bitSet + <span class="string">" , and bitSet1 is: "</span> + bitSet1);</span><br><span class="line">    System.out.println(<span class="string">"run bitSet.XMethod(bitSet1) , result is : "</span>);</span><br><span class="line">    System.out.println(<span class="string">"and:"</span> + bitSetAnd);</span><br><span class="line">    System.out.println(<span class="string">"andNot:"</span> + bitSetAndNot);</span><br><span class="line">    System.out.println(<span class="string">"or:"</span> + bitSetOr);</span><br><span class="line">    System.out.println(<span class="string">"xor:"</span> + bitSetXor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bitSet is : &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; , and bitSet1 is: &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">run bitSet.XMethod(bitSet1) , result is :</span><br><span class="line">and:&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">andNot:&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">or:&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">xor:&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="自己实现-BitMap"><a href="#自己实现-BitMap" class="headerlink" title="自己实现 BitMap"></a>自己实现 BitMap</h3><p>Java 的 BitSet 使用起来存在局限性，我们可以参考 BitSet 实现自己的 BitMap 来扩展应用场景。核心还是通过 int/long 数组元素的位来记录有序数据，一个实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] words;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="comment">//每个int占32位，数组大小为 n/32+1</span></span><br><span class="line">        words = <span class="keyword">new</span> <span class="keyword">int</span>[(size &gt;&gt; <span class="number">5</span>) + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得数据所在的数组序号（int），相当于 bit/32</span></span><br><span class="line">        <span class="keyword">int</span> i = bit &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//获得该int元素中要修改为1的数字,相当于 bit%32</span></span><br><span class="line">        <span class="keyword">int</span> j = bit &amp; <span class="number">31</span>;</span><br><span class="line">        <span class="comment">//获得要修改的位</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">        <span class="comment">//将该元素相应的二进制位设为1</span></span><br><span class="line">        words[i] |= k ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//参考set方法理解</span></span><br><span class="line">        <span class="keyword">return</span> (words[bit &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (bit &amp; <span class="number">31</span>))) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了核心的存储结构、set 和 get 方法。</p><h3 id="布隆过滤器-Bloom-Filter"><a href="#布隆过滤器-Bloom-Filter" class="headerlink" title="布隆过滤器(Bloom Filter)"></a>布隆过滤器(Bloom Filter)</h3><p>了解完 BitMap,我们掌握了一种处理大量连续数据的好方法。现在继续扩展一下，现在如果我们要记录的是海量的分布很不均匀的数据，如果继续用 BitMap 的方式，将会浪费大量的存储空间，或者数据量已经大到使用 BitMap 的方式，仍然会浪费大量的内存空间。面对这两种情情况时，我们可以考虑使用布隆过滤器。</p><p>布隆过滤器核心是对一个 key 使用多个 hash 函数求出多个值，将这些值散列在一个有限的数组中，这样，当这些 hash 函数求出的值都符合预期就认为该 key 存在；若只要存在 hash 函数的值不符合，就可以确定它不存在。在某些场景下，这种方法效果非常好。图示如下：</p><img src="/2018/10/08/BitMap、BitSet与Bloom%20Filter/bloom_filter.jpeg"><p>可以看出来，这种方法存在一定误差，不过误差几率可以通过增加 hash 函数和散列数组大小来减小。还有一个问题就是，当某个 key 被删除后，不能直接在散列表中将对应的 value 去掉，因为可能会影响其他 key。针对这个问题，我们可以维护一个黑名单，每次计算 hash 前，先判断 key 是否在黑名单中，有则表示该 key 已删掉。</p><img src="/2018/10/08/BitMap、BitSet与Bloom%20Filter/IMG_1753.GIF" title="10栋*7层*2（至少2）套=140套 呵呵😅">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：5分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;先来看一个问题，假设现在有范围为 1-10 亿的 11 亿个 int 型整数，如何排除
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="BitMap" scheme="https://jasonsonghoho.github.io/public/tags/BitMap/"/>
    
      <category term="BitSet" scheme="https://jasonsonghoho.github.io/public/tags/BitSet/"/>
    
      <category term="布隆过滤器" scheme="https://jasonsonghoho.github.io/public/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="Bloom Filter" scheme="https://jasonsonghoho.github.io/public/tags/Bloom-Filter/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 HashMap(下)—— compute</title>
    <link href="https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94%20compute/"/>
    <id>https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap（下）—— compute/</id>
    <published>2018-09-23T16:19:04.000Z</published>
    <updated>2018-10-04T07:57:06.137Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/09/24/Java-8-HashMap（下）——%20compute/IMG_0011.JPG" title="故乡的月"><p><em>推荐阅读时间：5分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本篇接上篇 <a href="https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap-%E4%B8%8A-%E2%80%94%E2%80%94-%E7%BA%A2%E9%BB%91%E6%A0%91/">Java 8 HashMap (上)—— 红黑树</a>，<br>继续探讨 Java8 的HashMap 的新特性。内容不多，重点介绍 compute 方法。</p><h3 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h3><p>compute 方法主要用来将一个复杂计算的结果作为值赋给指定的键。key 指待修改或插入的键，remappingFunction 是一个 BiFunction 对象。<br>BiFunction 是指一个 二元（binary）函数；定义时，指定两个入参字段类型和一个结果字段类型。通过实现 apply 方法来自定义计算逻辑。</p><p>BiFunction 部分源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>compute 方法源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//根据 key 值，找到对应的 旧值</span></span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">    <span class="comment">//计算出新值</span></span><br><span class="line">    V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果新值为 null，删掉这个 Node</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新值不为 null，替换这个 Node</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>computeIfAbsent、computeIfPresent 方法与 compute 类似，分别表示当相应键的值缺席、存在时，才进行 compute 方法。<br>源码与 compute 基本一致，不赘述。</p><p>demo 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">    hashMap.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">    hashMap.put(<span class="string">"k3"</span>, <span class="string">"v3"</span>);</span><br><span class="line">    Function&lt;String, String&gt; function = <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"test_"</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    BiFunction&lt;String, String, String&gt; biFunction = <span class="keyword">new</span> BiFunction&lt;String, String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s, String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"test_"</span> + s + <span class="string">"_"</span> + s2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    hashMap.compute(<span class="string">"k1"</span>, biFunction);<span class="comment">//生效</span></span><br><span class="line">    hashMap.compute(<span class="string">"k11"</span>, biFunction);<span class="comment">//生效</span></span><br><span class="line">    hashMap.computeIfAbsent(<span class="string">"k2"</span>, function);<span class="comment">//不生效</span></span><br><span class="line">    hashMap.computeIfAbsent(<span class="string">"k21"</span>, function);<span class="comment">//生效</span></span><br><span class="line">    hashMap.computeIfPresent(<span class="string">"k3"</span>, biFunction);<span class="comment">//生效</span></span><br><span class="line">    hashMap.computeIfPresent(<span class="string">"k31"</span>, biFunction);<span class="comment">//不生效</span></span><br><span class="line">    System.out.println(hashMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;k1=test_k1_v1, k2=v2, k3=test_k3_v3, k11=test_k11_null, k21=test_k21&#125;</span><br></pre></td></tr></table></figure></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge 方法是根据旧值进行计算，修改相应 Node。与 compute 结构相似，不过 BiFunction 入参为 oldValue,newValue。<br>源码与 compute 基本一致，不赘述。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他新增的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>getOrDefault 方法根据 key 获取相应的值，如果为 null，则返回设置的默认值。</li><li>putIfAbsent 方法会在 指定的 key 不存在时，插入相应的值。</li><li>remove(Object key, Object value) 方法会根据 key 和 value 进行删除，如果 相应 key 的值不为该 value，则不执行删除并返回 false。</li><li>replace(K key, V oldValue, V newValue) 与 replace(K key, V value) 都是替换值的操作，具体区别与上述方法类似。</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>HashMap历时一个半月，终于告一段落了😂。</p><p>由于在源码分析系列含有大量代码，放在公众号上不方便阅读，后续写的话会发在博客上。有兴趣的欢迎访问 <a href="http://jasonsonghoho.github.io">http://jasonsonghoho.github.io</a> 。</p><hr><img src="/2018/09/24/Java-8-HashMap（下）——%20compute/IMG_0007.JPG"><p><em>“你不知<br>这风雪一程<br>有太多不易”</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/09/24/Java-8-HashMap（下）——%20compute/IMG_0011.JPG&quot; title=&quot;故乡的月&quot;&gt;
&lt;p&gt;&lt;em&gt;推荐阅读时间：5分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="HashMap" scheme="https://jasonsonghoho.github.io/public/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 HashMap(上)—— 红黑树</title>
    <link href="https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap-%E4%B8%8A-%E2%80%94%E2%80%94-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://jasonsonghoho.github.io/2018/09/24/Java-8-HashMap-上-——-红黑树/</id>
    <published>2018-09-23T16:19:04.000Z</published>
    <updated>2018-09-23T16:45:18.176Z</updated>
    
    <content type="html"><![CDATA[<p><em>推荐阅读时间：10分钟</em></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Java8的最大特性是使用红黑树结构来存储每个（桶）bucket中的数据（当链表长度超过8时）。<br>为什么引入红黑树呢？其实正常情况下，平均每个桶中应该只会有不到1个数据，但当发生大量Hash碰撞时，每个桶中的数据也将会大量增加，这将会影响到数据的查询速度。在Java7中，每个桶使用链表存储数据，查找数据采用遍历的方式，查询时间复杂度为O(n)。Java7中为了避免大量Hash碰撞的问题，引入了hashseed方式，增强了Hash函数的散列性。但是randomHashSeed方法调用的next方法在多线程运算时存在性能问题（待考证），故在Java8中被弃用。Java8中换了一个思路：使用红黑树来提高查找速度（O(logN)），即使发生大量hash碰撞也不会造成性能影响，这便是红黑树由来的原因。<br>Java7的HashMap一共有接近1200行代码，而到了Java8直接增加到了2400行，减去全局变量前新加的100行注释，相差1100行。其中TreeNode(红黑树)实现部分有600行代码，再加上其他方法对红黑树的适应性改动，可见红黑树部分是Java8 HashMap的主要改动。  </p></blockquote><h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><h4 id="继承关系如下："><a href="#继承关系如下：" class="headerlink" title="继承关系如下："></a>继承关系如下：</h4><img src="/2018/09/24/Java-8-HashMap-上-——-红黑树/20180923214733.png"><p>TreeNode继承了LinkedHashMap.Entry，LinkedHashMap.Entry继承了HashMap.Node，而Node其实就是上个版本的Entry（链表）结构。此处有个疑惑：TreeNode并没有使用LinkedHashMap.Entry的before和after字段，不知道为啥不直接继承Node类。</p><h4 id="字段和构造函数如下："><a href="#字段和构造函数如下：" class="headerlink" title="字段和构造函数如下："></a>字段和构造函数如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//常见的树结构</span></span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; parent;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; left;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; right;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; prev;</span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, HashMap.Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树全部方法如下："><a href="#红黑树全部方法如下：" class="headerlink" title="红黑树全部方法如下："></a>红黑树全部方法如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取根结点</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选取根结点</span></span><br><span class="line"><span class="comment"> * 红黑树进行左旋、右旋后，根结点可能移动，头结点需要重新指向新的根结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(HashMap.Node&lt;K,V&gt;[] tab, HashMap.TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; first = (HashMap.TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="comment">//如果根结点不是桶的第一个节点，则将根结点移动到头结点位置</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            HashMap.Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            HashMap.TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                ((HashMap.TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言红黑树结构是否正常，不正常则报异常停止</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据结点hash值、key和key的类型 进行红黑树查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//待查询结点的key的hash值若小于当前结点则进入左子树，否则进入右子树</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//如果hash值相等再比较key，一致则表示找到，返回结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//如果key不同，则看key的类型是否可比较，</span></span><br><span class="line">        <span class="comment">//如果可以比较则根据比较结果选择是否返回查询结果，还是继续查询左、右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据结点hash值、key 进行红黑树查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制比较两个结点的key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当两个类型不能直接比较时，通过对类名进行hash进行比较；若hash值也相等，判定b大。</span></span><br><span class="line"><span class="comment"> * 故一定会排出先后顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">            (d = a.getClass().getName().</span><br><span class="line">                    compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表转化为红黑树</span></span><br><span class="line"><span class="comment"> * 重要方法！当链表长度增加到红黑树转换阈值（默认8），且桶的数量不小于64 时触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(HashMap.Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (HashMap.TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//首结点作为根结点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果未能比较，调用强制比较方法，确保有序</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//当左或右子树为空时，插入链表上的一个结点</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//插入结点后，进行左旋、右旋重平衡，转换为红黑树</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保根结点是首结点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转换为链表</span></span><br><span class="line"><span class="comment"> * 当红黑树结点减少到链表还原阈值（默认6）时触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        HashMap.Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树插入新结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, HashMap.Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//插入结点与当前结点hash值相等时，查找左子树或右子树，若已包含待插入结点则直接返回结果</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">//若已比较到左子树或右子树为空时还没有找到，则插入该结点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashMap.Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            HashMap.TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((HashMap.TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除红黑树结点</span></span><br><span class="line"><span class="comment"> * 呃，这个方法和前面的比起来大同小异，不细看了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, HashMap.Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; first = (HashMap.TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; succ = (HashMap.TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">            (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//若删除结点后，达到链表还原阈值，则还原为链表</span></span><br><span class="line">        tab[index] = first.untreeify(map);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            HashMap.TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        HashMap.TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树分为两半</span></span><br><span class="line"><span class="comment"> * 扩容时，会将一个桶中的红黑树拆分为两个；若拆分后红黑树不够大，会被还原为链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, HashMap.Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (HashMap.TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树的左旋</span></span><br><span class="line"><span class="comment"> * 红黑树相关知识待深入学习后进一步探讨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              HashMap.TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树的右旋</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               HashMap.TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入结点后进行重平衡</span></span><br><span class="line"><span class="comment"> * 这部分只看懂代码了，算法比较懵，有机会再探讨红黑树算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root, HashMap.TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将插入的结点设为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//x为根结点时，设为黑色，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//父结点为黑且为根结点时，直接返回。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//父结点为祖父结点的左孩子结点时：</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//祖父结点的右孩子结点为红色时，叔叔结点和父结点置黑，祖父结点置红，设置当前结点为祖父结点</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则，如果当前结点为父结点的右孩子结点，进行左旋</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果父结点不为空设为黑色，且如果祖父结点不为空则设为红色并进行右旋</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除结点后进行重平衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; HashMap.<span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   HashMap.TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                        (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                HashMap.TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                        (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查红黑树结构是否正常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(HashMap.TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">            tb = t.prev, tn = (HashMap.TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/09/24/Java-8-HashMap-上-——-红黑树/IMG_1756.GIF"><p>Java8的HashMap解读暂告一段落，下期继续探讨其他特性，希望不要太久😂</p><p><a href="https://y.qq.com/n/yqq/song/004dbfuf1jEjpI.html#stat=y_new.index.new_song.songname" target="_blank" rel="noopener">https://y.qq.com/n/yqq/song/004dbfuf1jEjpI.html#stat=y_new.index.new_song.songname</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;推荐阅读时间：10分钟&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Java8的最大特性是使用红黑树结构来存储每个（桶）buc
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="HashMap" scheme="https://jasonsonghoho.github.io/public/tags/HashMap/"/>
    
      <category term="红黑树" scheme="https://jasonsonghoho.github.io/public/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 7 HashMap 源码解读</title>
    <link href="https://jasonsonghoho.github.io/2018/08/18/Java-7-HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://jasonsonghoho.github.io/2018/08/18/Java-7-HashMap-源码解读/</id>
    <published>2018-08-18T02:31:46.000Z</published>
    <updated>2018-09-22T02:33:29.034Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/nHk9jKapNVVkBDnKChgK0Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nHk9jKapNVVkBDnKChgK0Q</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/nHk9jKapNVVkBDnKChgK0Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/nHk9jKapNVVkBDn
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/public/tags/Java/"/>
    
      <category term="HashMap" scheme="https://jasonsonghoho.github.io/public/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>React快速入门</title>
    <link href="https://jasonsonghoho.github.io/2018/06/24/React%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://jasonsonghoho.github.io/2018/06/24/React快速入门/</id>
    <published>2018-06-24T02:34:27.000Z</published>
    <updated>2018-09-22T02:52:12.539Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zfzKQr1jQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zfzKQr1jQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zfzKQr1jQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/fDXQe_QCBN4q6zf
      
    
    </summary>
    
      <category term="前端" scheme="https://jasonsonghoho.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="React" scheme="https://jasonsonghoho.github.io/public/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>动物园管理员——ZooKeeper</title>
    <link href="https://jasonsonghoho.github.io/2018/06/05/%E5%8A%A8%E7%89%A9%E5%9B%AD%E7%AE%A1%E7%90%86%E5%91%98%E2%80%94%E2%80%94ZooKeeper/"/>
    <id>https://jasonsonghoho.github.io/2018/06/05/动物园管理员——ZooKeeper/</id>
    <published>2018-06-05T02:35:00.000Z</published>
    <updated>2018-09-22T02:52:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoXHKwJhiw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoXHKwJhiw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoXHKwJhiw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/hnfWq1sHD8qxKoX
      
    
    </summary>
    
      <category term="中间件" scheme="https://jasonsonghoho.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="ZooKeeper" scheme="https://jasonsonghoho.github.io/public/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>MySQL究竟如何解决“不可重复读”和“幻读”的</title>
    <link href="https://jasonsonghoho.github.io/2018/05/27/MySQL%E7%A9%B6%E7%AB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%80%9C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E2%80%9D%E5%92%8C%E2%80%9C%E5%B9%BB%E8%AF%BB%E2%80%9D%E7%9A%84/"/>
    <id>https://jasonsonghoho.github.io/2018/05/27/MySQL究竟如何解决“不可重复读”和“幻读”的/</id>
    <published>2018-05-26T16:35:44.000Z</published>
    <updated>2018-09-22T02:30:44.066Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL0-J8tIQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL0-J8tIQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL0-J8tIQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/Ej3coEuouPqbzkL
      
    
    </summary>
    
      <category term="数据库" scheme="https://jasonsonghoho.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="mysql" scheme="https://jasonsonghoho.github.io/public/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>我们为提升 Cassandra 读性能做了哪些努力？</title>
    <link href="https://jasonsonghoho.github.io/2018/05/21/180521/"/>
    <id>https://jasonsonghoho.github.io/2018/05/21/180521/</id>
    <published>2018-05-21T14:08:41.000Z</published>
    <updated>2018-09-20T15:23:28.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title=" 目录 (Table of Contents)"></a> <strong>目录 (Table of Contents)</strong></h2><ul><li>关于Cassandra</li><li>提升读性能</li></ul><h2 id="关于Cassandra"><a href="#关于Cassandra" class="headerlink" title="关于Cassandra"></a>关于Cassandra</h2><p>Apache Cassandra是一个高度可扩展的高性能分布式数据库，<br>用于处理大量常规服务器上的大量数据，提供高可用性，无单点故障。它是一种NoSQL类型的数据库。</p><p>我们看一下国外权威机构<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">DB-Engines</a>最近的数据库全球流行程度排名：</p><img src="/2018/05/21/180521/database_rank.png" title="数据库排名"><p>可以看出，Cassandra 是排名前十中四个仅有的NoSQL数据库之一。Cassandra在国外这样受欢迎，其性能可想而知不会差，<br>但是在国内貌似还没有多少公司使用，且国内关于 Cassandra方面的资料较少。</p><h2 id="提升读性能"><a href="#提升读性能" class="headerlink" title="提升读性能"></a>提升读性能</h2><p>Cassandra 在我们的项目中用来存储时序数据，经过测试，在三台4核16G的虚拟机上，<br>指标数据的写入TPS可以达到6.5W/s，基本可以满足我们的业务需求。<br>但是读取性能可能就会差很多，因为数据查询速度跟每次查询的数据量关系比较大，此处也不好定义TPS。<br>产品查询一周以上的指标数据时，经常会出现加载缓慢，甚至查询超时。为了改善查询状况，我们进行了不少努力。</p><p>此处不讨论纵向扩展和横向扩展带来的性能提升。</p><h3 id="1-加快墓碑回收甚至去除墓碑"><a href="#1-加快墓碑回收甚至去除墓碑" class="headerlink" title="1. 加快墓碑回收甚至去除墓碑"></a>1. 加快墓碑回收甚至去除墓碑</h3><p>在Cassandra中，当你删除一条数据时，其实是给这条数据进行update，给它update上一个标识，就是一个墓碑标识。<br> 当Cassandra集群在不同节点之间同步删除信息的时候，也会用到Tombstones(墓碑)，可以说墓碑是一种允许Cassandra快速写入的机制。</p><p>关于墓碑的更多消息，可参考 <a href="https://docs.datastax.com/en/Cassandra/3.0/Cassandra/dml/dmlHowDataMaintain.html" target="_blank" rel="noopener">Cassandra 数据维护官方文档</a></p><p>可以这样理解，大量的墓碑数据会使查询时搜索的数据量变大，直接影响查询时的效率。<br>所以，为了消除这种影响，我们可以加快墓碑数据的回收，避免产生大量的墓碑数据。<br>甚至，当我们在写入时，若写入一致性的值与副本因子数量相等时，可以不产生墓碑数据，直接删掉该无效数据。<br>具体可通过 调整 table 中 gc_grace_seconds 参数来实现，默认为 864000（10天），我们可以设为 86400（1天）或者0（直接删除）。</p><h3 id="2-降低read-repair-的几率"><a href="#2-降低read-repair-的几率" class="headerlink" title="2. 降低read repair 的几率"></a>2. 降低read repair 的几率</h3><p>每一次读操作，Cassandra都会在后台进行read repair操作。<br>如果只要求读一个节点数据，Cassandra在读到一个节点后，就将结果返回客户端，<br>然后用read repair对其他的replicas进行同步（根据timestamp）。<br>如果要求读多个节点，那么Cassandra就读多个节点，然后根据timestamp进行比较，返回客户端最新的数据，<br>然后再调用read repair对其他节点进行同步。<br>Read repair在后台的操作，会占用一定的CPU和I/O,所以影响读性能。<br>我们可以降低read repair 的几率，以提高读取性能。</p><p>通过修改 table 中 read_repair_chance（取值范围 0-1）参数来设置read repair 的几率，建议设为 0.1。</p><h3 id="3-指标数据预聚合"><a href="#3-指标数据预聚合" class="headerlink" title="3. 指标数据预聚合"></a>3. 指标数据预聚合</h3><p>思路：我们存在数据库中的指标数据，读取时会将指定时间范围内的数据进行聚合。<br>如果提前将数据按基本时间段提前聚合为一个值，读取时，只读取时间范围内的时间段的汇聚结果，将大大减少查询耗时。</p><h3 id="4-合理部署产品"><a href="#4-合理部署产品" class="headerlink" title="4. 合理部署产品"></a>4. 合理部署产品</h3><p>公司的其他产品使用了mongoDB，线上环境中发现，这两个NoSQL数据库部署在一起时会相互争夺内存资源，<br>十分影响性能，因此最好将这两个数据库分开部署。</p><h3 id="5-设置合理的堆内存大小和GC策略"><a href="#5-设置合理的堆内存大小和GC策略" class="headerlink" title="5. 设置合理的堆内存大小和GC策略"></a>5. 设置合理的堆内存大小和GC策略</h3><p>堆内存设置的太小，将导致频繁GC甚至OOM，设置的太大同样也不好。可参考官方的公式:<br><code>MAX_HEAP_SIZE=max(min(1/2 ram, 1024MB), min(1/4 ram, 8GB)</code></p><p>关于GC策略，官方的建议是：小于16G，用CMS收集器；16-64G，用G1收集器。</p><h3 id="6-设置合理的压式策略"><a href="#6-设置合理的压式策略" class="headerlink" title="6. 设置合理的压式策略"></a>6. 设置合理的压式策略</h3><p>Cassandra 将落到磁盘的数据存放在SStable中，压实是将多个SSTable 文件合并为一个的过程。合并后将减少重复的数据，使数据更紧凑。<br>Cassandra 有多种触发压实的策略，选一个适合的压实策略，可以更好地压实数据。<br>比如，我们使用的Kairosdb建议采用 DateTieredCompactionStrategy (<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html#dmlHowDataMaintain__dtcs-compaction" target="_blank" rel="noopener">DTCS</a>))压实策略。</p><h3 id="7-启用-row-cache"><a href="#7-启用-row-cache" class="headerlink" title="7. 启用 row cache"></a>7. 启用 row cache</h3><p>row cache 把整个row 的内容都放在内存中。<br>适合的情况是，有一小部分hot data是经常反问的，或者要返回整个columns.在使用row cache时，用注意它对内存的影响。<br>可参考 Cassandra 的<a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsConfiguringCaches.html" target="_blank" rel="noopener">官方文档</a>设置row cache。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>安利一个入门Cassandra 的好博客：<a href="http://teddymaef.github.io/learnCassandra/cn/" target="_blank" rel="noopener">learn Cassandra</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录-Table-of-Contents&quot;&gt;&lt;a href=&quot;#目录-Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot; 目录 (Table of Contents)&quot;&gt;&lt;/a&gt; &lt;strong&gt;目录 (Table of C
      
    
    </summary>
    
      <category term="数据库" scheme="https://jasonsonghoho.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="cassandra" scheme="https://jasonsonghoho.github.io/public/tags/cassandra/"/>
    
      <category term="大数据" scheme="https://jasonsonghoho.github.io/public/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的top命令详解</title>
    <link href="https://jasonsonghoho.github.io/2018/05/20/Linux%E4%B8%AD%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jasonsonghoho.github.io/2018/05/20/Linux中的top命令详解/</id>
    <published>2018-05-20T02:41:23.000Z</published>
    <updated>2018-09-22T02:52:12.563Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y9MM-7JA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y9MM-7JA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y9MM-7JA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/xyYn6xaahQ4hv1y
      
    
    </summary>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/categories/Linux/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/public/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的 Cache、Buffer、MemAvailable、Swap简介</title>
    <link href="https://jasonsonghoho.github.io/2018/05/20/Linux-%E7%9A%84-Cache%E3%80%81Buffer%E3%80%81MemAvailable%E3%80%81Swap%E7%AE%80%E4%BB%8B/"/>
    <id>https://jasonsonghoho.github.io/2018/05/20/Linux-的-Cache、Buffer、MemAvailable、Swap简介/</id>
    <published>2018-05-20T02:40:08.000Z</published>
    <updated>2018-09-22T02:52:12.543Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/59oH1hMMXy6YC618gZkm1g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/59oH1hMMXy6YC618gZkm1g</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/59oH1hMMXy6YC618gZkm1g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/59oH1hMMXy6YC61
      
    
    </summary>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/categories/Linux/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Linux" scheme="https://jasonsonghoho.github.io/public/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>克拉丝的面试</title>
    <link href="https://jasonsonghoho.github.io/2018/05/13/%E5%85%8B%E6%8B%89%E4%B8%9D%E7%9A%84%E9%9D%A2%E8%AF%95/"/>
    <id>https://jasonsonghoho.github.io/2018/05/13/克拉丝的面试/</id>
    <published>2018-05-13T02:39:39.000Z</published>
    <updated>2018-09-22T02:52:46.942Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU_mAUWbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU_mAUWbA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU_mAUWbA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/boQUsfwjf0pPtcU
      
    
    </summary>
    
      <category term="Java" scheme="https://jasonsonghoho.github.io/categories/Java/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="JVM" scheme="https://jasonsonghoho.github.io/public/tags/JVM/"/>
    
      <category term="类加载" scheme="https://jasonsonghoho.github.io/public/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式、简单工厂模式与抽象工厂模式</title>
    <link href="https://jasonsonghoho.github.io/2018/05/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jasonsonghoho.github.io/2018/05/10/工厂模式、简单工厂模式与抽象工厂模式/</id>
    <published>2018-05-10T02:39:16.000Z</published>
    <updated>2018-09-22T02:52:12.556Z</updated>
    
    <content type="html"><![CDATA[<p>见链接：<a href="https://mp.weixin.qq.com/s/ccNz_veqyb4UYBpH-UpZfA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ccNz_veqyb4UYBpH-UpZfA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/ccNz_veqyb4UYBpH-UpZfA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/ccNz_veqyb4UYBp
      
    
    </summary>
    
      <category term="设计模式" scheme="https://jasonsonghoho.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="公众号文章" scheme="https://jasonsonghoho.github.io/public/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="设计模式" scheme="https://jasonsonghoho.github.io/public/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
